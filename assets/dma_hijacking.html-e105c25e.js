import{_ as s,r as o,o as r,c as d,a as i,b as e,d as n,e as a}from"./app-3be15a72.js";const l={},c=i("h1",{id:"dma-hijacking",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#dma-hijacking","aria-hidden":"true"},"#"),e(" DMA Hijacking")],-1),h={href:"https://github.com/ISSOtm",target:"_blank",rel:"noopener noreferrer"},u=a('<div class="custom-container tip"><p class="custom-container-title">TARGET AUDIENCE</p><p>Unlike most resources here, this guide is not very useful to developers or even ROM hackers, but rather to glitch-hunters and exploit developers.</p></div><hr><h2 id="what-is-it" tabindex="-1"><a class="header-anchor" href="#what-is-it" aria-hidden="true">#</a> What is it?</h2><p><em>OAM DMA hijacking</em> is a simple technique that allows you to run custom code in most GB/SGB/CGB games, provided you have an ACE exploit.</p><p>One would be quick to point out that if you have an ACE exploit, you can already execute custom code. So then, what is the point? It&#39;s that code ran through DMA Hijacking will be run <em>on every game frame</em> (for most games, at least).</p><h2 id="how-is-it-done" tabindex="-1"><a class="header-anchor" href="#how-is-it-done" aria-hidden="true">#</a> How is it done?</h2>',6),m={href:"https://gbdev.io/pandocs/OAM",target:"_blank",rel:"noopener noreferrer"},p=i("em",null,"OAM DMA",-1),v={href:"https://gbdev.io/pandocs/OAM_DMA_Transfer",target:"_blank",rel:"noopener noreferrer"},b={href:"https://gbdev.io/pandocs/Rendering#objects",target:"_blank",rel:"noopener noreferrer"},g=i("p",null,[e("Interestingly, most games only copy the routine when starting up, and then execute it on every subsequent frame. But, "),i("em",null,"if we modified that routine while the game is running"),e(", then the game will happily run the customized routine!")],-1),f=i("h3",{id:"patching-the-code",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#patching-the-code","aria-hidden":"true"},"#"),e(" Patching the code")],-1),w={href:"https://rgbds.gbdev.io/docs/rgbasm.5",target:"_blank",rel:"noopener noreferrer"},y={href:"https://github.com/gbdev/hardware.inc",target:"_blank",rel:"noopener noreferrer"},k=i("code",null,"hardware.inc",-1),A=a(`<div class="language-asm line-numbers-mode" data-ext="asm"><pre class="language-asm"><code>    ld a, HIGH(OAMBuffer)
    ldh [rDMA], a  ; $FF46
    ld a, 40
DMALoop:
    dec a
    jr nz, DMALoop
    ret
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The simplest way to get custom code (let&#39;s call it <code>DMAHook</code>) executed would be to overwrite the first few bytes with a jump to <code>DMAHook</code>:</p><div class="language-asm line-numbers-mode" data-ext="asm"><pre class="language-asm"><code>    jp DMAHook
    db $46    ; Leftover operand byte of \`ldh [rDMA], a\`
    ld a, 40  ; None of this is executed
DMALoop:
    dec a
    jr nz, DMALoop
    ret
</code></pre><div class="highlight-lines"><div class="highlight-line"> </div><br><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),_={href:"https://gbdev.io/pandocs/OAM_Corruption_Bug",target:"_blank",rel:"noopener noreferrer"},M=i("code",null,"rDMA",-1),D=i("code",null,"DMAHook",-1),H=i("strong",null,"must",-1),x=a(`<p>But, there is a solution.</p><div class="language-asm line-numbers-mode" data-ext="asm"><pre class="language-asm"><code>    call DMAHook
    ldh [c], a  ; A write to \`rDMA\`, set up by DMAHook
    ld a, 40
DMALoop:
    dec a
    jr nz, DMALoop
    ret
</code></pre><div class="highlight-lines"><div class="highlight-line"> </div><div class="highlight-line"> </div><br><br><br><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Provided that <code>DMAHook</code> returns with properly set registers, this allows writing to <code>rDMA</code> in the single HRAM byte left by the <code>call</code> instruction. Here is a pattern for DMAHook :</p><div class="language-asm line-numbers-mode" data-ext="asm"><pre class="language-asm"><code>DMAHook:
    ;;  Custom code, do whatever you want, it&#39;s VBlank time!
    ; ...
    ld c, LOW(rDMA)  ; $46
    ld a, HIGH(OAMBuffer)
    ret
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>DMAHook</code> can live anywhere in memory, but typically it will be in WRAM. It will be executed in the context of the VBlank interrupt, so for most games interrupts will be disabled, etc.</p><h2 id="with-cartswap" tabindex="-1"><a class="header-anchor" href="#with-cartswap" aria-hidden="true">#</a> With Cartswap</h2>`,6),O={href:"https://gist.github.com/ISSOtm/3008fd73ec66cb56f1caecfcc8b6fb6f",target:"_blank",rel:"noopener noreferrer"},j=a("<p>General procedure:</p><ol><li>Acquire ACE in the &quot;source&quot; game</li><li>Perform cartswap, insert the &quot;victim&quot; game</li><li>&quot;Pseudo-initialize&quot; the victim</li><li>Place the modified DMA handler in HRAM</li><li>Transfer control back to the victim&#39;s ROM</li><li>????</li><li>Profit!</li></ol><p>Possible applications are checking for a button combo to trigger specific code (for example, credits warp), checking one or multiple memory addresses to detect a certain game state, etc.</p><p>Possible &quot;attack vectors&quot;, i.e. ways of affecting the victim game, are setting certain memory addresses (like a GameShark), or even better: manipulating the stack.</p><p>Here is a video demonstration:</p>",5),B=i("iframe",{width:"560",height:"315",src:"https://www.youtube-nocookie.com/embed/BNyDmZlbsNI",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:""},null,-1),q=i("p",null,"Manipulating the stack with this technique can not crash if the triggering game state is specific enough. I achieved text pointer manipulation in Pokémon Red this way. (This is not a ROM hack!)",-1),I=i("iframe",{width:"560",height:"315",src:"https://www.youtube-nocookie.com/embed/yXy5sYZR9mk",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:""},null,-1),T=i("h3",{id:"details",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#details","aria-hidden":"true"},"#"),e(" Details")],-1),L={href:"https://gbdev.io/pandocs/The_Cartridge_Header#0100-0103---entry-point",target:"_blank",rel:"noopener noreferrer"},G=a('<p>However, since we have control of the CPU, we can jump to any location in the game&#39;s ROM, which allows bypassing some of said initialization. Doing so without any precautions is very likely to go haywire, though—it is important to initialize <em>enough</em> that the game runs, but not <em>too much</em> that it would end up overwriting the code we are trying to inject. This is what I call &quot;<strong>pseudo-initialization</strong>&quot;.</p><p>Another important part is finding some free space to store the hook code in. The stack area can work surprisingly well for this, as many games appear to over-allocate (e.g. 256 bytes when the typical usage doesn&#39;t go beyond 32).</p><p>None of this has a silver bullet: the game&#39;s init code must be analyzed, and its memory usage carefully scrutinized in order to dig up enough free space for your hook.</p><h2 id="trivia" tabindex="-1"><a class="header-anchor" href="#trivia" aria-hidden="true">#</a> Trivia</h2><p>DMA hijacking works similarly to the GameShark: that device intercepts accesses to the ROM, and when it detects that the VBlank handler is being run, it &quot;overlays&quot; different instructions that apply the stored codes, and jump back to the actual handler.</p>',5),R={href:"http://gbdev.gg8.se/forums/viewtopic.php?id=430",target:"_blank",rel:"noopener noreferrer"},C=a(`<h2 id="notes" tabindex="-1"><a class="header-anchor" href="#notes" aria-hidden="true">#</a> Notes</h2><ul><li><p>I encountered some games that don&#39;t transfer OAM unless a specific flag is set; I believe that it is always possible to override this limitation, by setting the flag back in the hook.</p></li><li><p>The OAM DMA routine is often placed at $FF80 in commercial games.</p></li><li><p>The patched OAM DMA routine with our hook may be modifying registers that the game expects to be preserved. This is all dependent on the target game, so no general advice can be given.</p><p>Additionally, if the hook takes too long, it may cause code expecting to run in VBlank to break. This might be solved for example by manipulating the stack and injecting an additional return address; here is an example.</p><div class="language-asm line-numbers-mode" data-ext="asm"><pre class="language-asm"><code>    jp DMAHook
PostDMAHook:
    ldh [c], a
    ld a, 40
DMALoop:
    dec a
    jr nz, DMALoop
    jp hl
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-asm line-numbers-mode" data-ext="asm"><pre class="language-asm"><code>    pop hl  ; Get original return address
    ld bc, PostHandlerHook  ; Address of code that will be executed once the VBlank handler finishes
    push bc  ; Inject return address for VBlank handler
    ld c, LOW(rDMA)
    ld a, HIGH(OAMBuffer)
    jp PostDMAHook
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(Since the handler almost certainly performs some <code>pop</code>s before returning, you will almost certainly need more complex stack manipulation, but that&#39;s the gist of it.)</p></li><li><p>Some games have a slightly more clever routine in HRAM, that omits the initial <code>ld a, HIGH(OAMBuffer)</code> saving 2 bytes of HRAM.</p><div class="language-asm line-numbers-mode" data-ext="asm"><pre class="language-asm"><code>    ldh [rDMA], a
    ld a, 40
DMALoop:
    dec a
    jr nz, DMALoop
    ret
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>They can still be patched by overwriting the <code>ld a, 40</code> instead, and using e.g. the <code>b</code> register for the loop:</p><div class="language-asm line-numbers-mode" data-ext="asm"><pre class="language-asm"><code>    call DMAHook
    ldh [c], a  ; Write to rDMA
DMALoop:
    dec b
    jr nz, DMALoop
    ret
</code></pre><div class="highlight-lines"><div class="highlight-line"> </div><div class="highlight-line"> </div><br><div class="highlight-line"> </div><br><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Then <code>DMAHook</code> needs to return with <code>b</code> additionally set to 40:</p><div class="language-asm line-numbers-mode" data-ext="asm"><pre class="language-asm"><code>DMAHook:
    ;;  Custom code, do whatever you want, it&#39;s VBlank time!
    ; ...
    ld bc, 40 &lt;&lt; 8 | LOW(rDMA)  ; 40 in B, $46 in C
    ld a, HIGH(OAMBuffer)
    ret
</code></pre><div class="highlight-lines"><br><br><br><div class="highlight-line"> </div><div class="highlight-line"> </div><br></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>However, if the OAM buffer address passed to the function (in <code>a</code>) is not static, <code>push af</code> and <code>pop af</code> will have to be used instead of <code>ld a, HIGH(OAMBuffer)</code>.</p></li></ul>`,2);function S(z,P){const t=o("ExternalLinkIcon");return r(),d("div",null,[c,i("p",null,[e("Written by "),i("a",h,[e("ISSOtm"),n(t)]),e(".")]),u,i("p",null,[e("If you are familiar enough with "),i("a",m,[e("OAM"),n(t)]),e(", you may know about a feature called "),p,e(".")]),i("p",null,[i("a",v,[e("OAM DMA"),n(t)]),e(" is a convenient feature that allows quickly updating the on-screen "),i("a",b,[e('"objects"'),n(t)]),e(' (often known as "sprites") quickly—which is especially useful since it typically needs to occur on every frame. However, using OAM DMA requires a small routine to be copied to HRAM and then run from there.')]),g,f,i("p",null,[e("Here is the standard routine, given by Nintendo in the GB programming manual (using "),i("a",w,[e("RGBASM syntax"),n(t)]),e(" and a symbol from "),i("a",y,[k,n(t)]),e("):")]),A,i("p",null,[e("Now, overwriting the routine like this works for our purposes, but comes with a large drawback: the routine isn't doing what it is intended to anymore, and so the game's objects won't update (unless you manually copied OAM, but beware of "),i("a",_,[e("the OAM corruption bug"),n(t)]),e("). Further, it's not possible to write to "),M,e(" from "),D,e(", as the write and subsequent wait loop "),H,e(" be executed from HRAM.")]),x,i("p",null,[e("DMA Hijacking is also useful when combined with "),i("a",O,[e("cartswap"),n(t)]),e(' (swapping carts without shutting the console down, concept found by furrtek, developed by Cryo and me on the GCL forums), because it allows "transporting" ACE to other games.')]),j,B,q,I,T,i("p",null,[e("This new technique hinges on breaking one of any game's core assumptions: its entry point. You see, normally, "),i("a",L,[e("the console transfers control to the game at address $0100"),n(t)]),e(", so any code placed there is designed to initialize all of the game's systems, in particular their memory.")]),G,i("p",null,[e("And, why yes, it is possible to use DMA hijacking to emulate GameShark codes! "),i("a",R,[e("Here is a proof-of-concept in Pokémon Red"),n(t)]),e(".")]),C])}const V=s(l,[["render",S],["__file","dma_hijacking.html.vue"]]);export{V as default};
