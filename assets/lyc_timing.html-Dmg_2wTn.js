import{f as j,u as O,g as P,h as N,n as V,i as z,o as R,j as o,_ as $,c as G,a as S,b as l,d as e,e as h,w,r as _}from"./app-BCkEzF8M.js";import{_ as W}from"./xysine-B17jd6VP.js";const J=`.waitVRAM
	ldh a, [rSTAT]
	and STATF_BUSY ; 2
	jr nz, .waitVRAM
`,X=`LYC::
    push af
    ldh a, [rLY]
    cp 128 - 1
    jr z, .disableSprites

    ; enable sprites
    ldh a, [rLCDC]
    or a, LCDCF_OBJON
    ldh [rLCDC], a
    pop af
    reti

.disableSprites
    ldh a, [rLCDC]
    and a, ~LCDCF_OBJON
    ldh [rLCDC], a
    pop af
    reti
`,K=`LYC::
    push af
    push hl
    ldh a, [rLY]
    cp 128 - 1
    jr z, .disableSprites

    ; enable sprites
    ldh a, [rLCDC]
    or a, LCDCF_OBJON
    jr .finish

.disableSprites
    ldh a, [rLCDC]
    and a, ~LCDCF_OBJON

.finish
    ld hl, rSTAT
.waitNotBlank
    bit STATB_BUSY, [hl]
    jr z, .waitNotBlank
.waitBlank
    bit STATB_BUSY, [hl]
    jr nz, .waitBlank

    ldh [rLCDC], a
    pop hl
    pop af
    reti
`,Q=`    push af ; 4
    push hl ; 8

    ; obtain the pointer to the data pair
    ldh a, [rLY] ; 11
    inc a ; 12
    add a, a ; 13 ; double the offset since each line uses 2 bytes
    ld l, a ; 14
    ldh a, [hDrawBuffer] ; 17
    adc 0 ; 19
    ld h, a ; 20 ; hl now points to somewhere in the draw buffer

    call UnconditionalRet ; just waste 31 cycles while we wait for HBlank to maybe start
    call UnconditionalRet
    call UnconditionalRet
    nop ; 51

    ; now start trying to look for HBlank to exit early

    ldh a, [rSTAT]
    and STATF_BUSY
    jr z, .setAndExit ; 58

    ldh a, [rSTAT]
    and STATF_BUSY
    jr z, .setAndExit ; 65

    ldh a, [rSTAT]
    and STATF_BUSY
    jr z, .setAndExit ; 72

    ldh a, [rSTAT]
    and STATF_BUSY
    jr z, .setAndExit ; 79

    nop ; waste 4 more cycles since there isn't time for another check
    nop
    nop
    nop ; 83

.setAndExit
    ; set the scroll registers
    ld a,[hl+] ; 85
    ldh [rSCY],a ; 88
    ld a,[hl+] ; 90
    ldh [rSCX],a ; 93

    pop hl ; 97
    pop af ; 100
    reti ; 104
`,M={};function Z(a){return a.getIsPending!==void 0}function ee(a){if(Z(a))return a;let s=!0,i=a.then(r=>(s=!1,r),r=>{throw s=!1,r});return i.getIsPending=function(){return s},i}function ne(a){let s={};const i=a.attributes;if(!i)return s;for(let r=i.length-1;r>=0;r--)s[i[r].name]=i[r].value;return s}function se(a){return Object.keys(a).reduce((s,i)=>(a[i]!==!1&&a[i]!==null&&a[i]!==void 0&&(s[i]=a[i]),s),{})}function ae(a,s){const{class:i,style:r,...g}=ne(a),{class:A,style:c,...y}=se(s);return{class:[i,A],style:[r,c],...g,...y}}const ie=j({inheritAttrs:!1,__name:"InlineSvg",props:{src:{},title:{default:void 0},transformSource:{type:Function,default:a=>a},keepDuringLoading:{type:Boolean,default:!0},uniqueIds:{type:[Boolean,String],default:!1},uniqueIdsBase:{default:""}},emits:["loaded","unloaded","error"],setup(a,{expose:s,emit:i}){const r=a,g=i,A=O(),c=P(),y=P(),n=Math.random().toString(36).substring(2);s({svgElSource:c,request:y}),N(()=>r.src,t=>{E(t)}),E(r.src);function p(t){if(t=t.cloneNode(!0),r.uniqueIds){const d=typeof r.uniqueIds=="string"?r.uniqueIds:n;t=v(t,d,r.uniqueIdsBase)}return t=r.transformSource(t),r.title&&f(t,r.title),t.innerHTML}function E(t){M[t]||(M[t]=L(t)),c.value&&M[t].getIsPending()&&!r.keepDuringLoading&&(c.value=null,g("unloaded")),M[t].then(d=>{c.value=d,V(()=>{g("loaded",document.querySelector("svg"))})}).catch(d=>{c.value&&(c.value=void 0,g("unloaded")),delete M[t],g("error",d)})}function L(t){return ee(new Promise((d,m)=>{const u=new XMLHttpRequest;u.open("GET",t,!0),y.value=u,u.onload=()=>{if(u.status>=200&&u.status<400)try{let b=new DOMParser().parseFromString(u.responseText,"text/xml").getElementsByTagName("svg")[0];b?d(b):m(new Error('Loaded file is not valid SVG"'))}catch(b){m(b)}else m(new Error("Error loading SVG"))},u.onerror=m,u.send()}))}const k=()=>c.value?o("svg",{...ae(c.value,A),innerHTML:p(c.value)}):null;function f(t,d){const m=t.getElementsByTagName("title");if(m.length)m[0].textContent=d;else{const u=document.createElementNS("http://www.w3.org/2000/svg","title");u.textContent=d,t.insertBefore(u,t.firstChild)}}function v(t,d,m=""){const u=["id","href","xlink:href","xlink:role","xlink:arcrole"],b=["href","xlink:href"],x=(T,B)=>b.includes(T)&&(B?!B.includes("#"):!1);return[...t.children].forEach(T=>{var B;if((B=T.attributes)!=null&&B.length){const I=Object.values(T.attributes).map(F=>{const D=/url\((.*?)\)/.exec(F.value);return D!=null&&D[1]&&(F.value=F.value.replace(D[0],`url(${m}${D[1]}_${d})`)),F});u.forEach(F=>{const D=I.find(Y=>Y.name===F);D&&!x(F,D.value)&&(D.value=`${D.value}_${d}`)})}return T.children.length?v(T,d,m):T}),t}return(t,d)=>(R(),z(k))}}),q=a=>a.split(/\r?\n/).map(s=>s.split(";")[0].trim()),le={"lyc_timing/stat_loop.asm":q(J),"lyc_timing/simple_handler.asm":q(X),"lyc_timing/ret_hblank_handler.asm":q(K),"lyc_timing/hybrid_handler.asm":q(Q)},C=114,U=21,te=51,oe={props:{offset:{type:Number,required:!0,validator(a){return a>=0&&a<=C}},hblankLength:{type:Number,default:U,validator(a){return a>=U&&a<=te}},asmFile:String},render(){const a=[20,C-this.$props.hblankLength,C],s=this.$props.asmFile;let i;if(s&&(i=le[s],i===void 0))throw new SyntaxError(`Unknown ASM file "${s}" (did you forget to register it in \`ASM_FILES\`?)`);let r=this.$slots.default(),g={},A=[],c=this.$props.offset,y=0;for(let p=0;p<r.length||y!==0;){let E=f=>c<a[0]?2:c<a[1]?3:0;const L="ppu-mode"+E();let k=[o("td",{class:L},""+c)];if(y==0){const f=r[p].props,v=function(){try{return H.info(f,i)}catch(b){throw b instanceof SyntaxError&&s&&f.line!==void 0&&(b.message+=` (at ${s}:${f.line})`),b}}(),t=v.instr;let d="cpu-"+(v.class||"op");f.io!==void 0&&(d+=" cpu-io");let m={rowspan:v.cycles,class:d,condensed:f.op==="condensed"},u=m.condensed?o("b",{},"(...)"):t&&o("code",{},t);k.push(o("td",m,u)),v.legend&&(g[d]={order:Object.keys(g).length,legend:v.legend}),y=v.cycles,++p}if(A.push(o("tr",{},k)),c++,c==C&&(c=0),y--,k[1]&&k[1].props.condensed){let f=k[1];if(f.props.rowspan>3){let v=()=>`var(--ppu-mode${E()})`;const t=f.props.rowspan-2;let d=t,m=[],u=a.findIndex(x=>x>c);for(;a[u]-c<d;){const x=v();d-=a[u]-c,c=a[u]%C,u=(u+1)%a.length;const T=100-parseInt(d*100/t);m.push(`${x} ${T}%, ${v()} ${T}%`)}c=(c+d)%C;const b=m.length?{"background-image":`linear-gradient(${m.join(", ")})`}:{"background-color":v()};A.push(o("tr",{},o("td",{style:b},o("b",{},"...")))),f.props.rowspan=3,y=1}}}const n=o("tr",{},[o("th",{},["Scanline",o("br"),"cycle"]),o("th",{},"Instruction")]);return o("figure",{class:"timeline-figure"},[o("div",{class:"timeline-legend"},[o("h3",{},"Legend"),o("table",{},[o("tr",{},o("th",{colspan:2},"PPU Mode")),...[{id:2,name:"OAM scan"},{id:3,name:"Drawing"},{id:0,name:"HBlank"}].map(p=>o("tr",{},[o("td",{class:"ppu-mode"+p.id},""+p.id),o("td",{},p.name)]))]),o("table",{},[o("tr",{},o("th",{colspan:2},"CPU operation")),...Object.entries(g).sort(([p,E],[L,k])=>E.order-k.order).map(([p,{legend:E}])=>o("tr",{},[o("td",{class:p}),o("td",{},E)]))])]),o("table",{},[o("thead",{},n),o("tfoot",{},n),o("tbody",{class:"timeline"},A)])])}},H={props:{op:String,line:{type:Number,validator(a){return a>0}},immediate:Boolean,io:Boolean,taken:Boolean,class:String,legend:String,cycles:Number},info(a,s){if(a.line!==void 0){if(s===void 0)throw new SyntaxError("ASM line requested, but no ASM file was provided!");a.instr=s[a.line-1]}a.instr!==void 0&&a.op===void 0&&(a.op=a.instr.split(/\s/)[0]);let i=function(){switch(a.op){case"and":return{cycles:1,instr:"and"};case"bit":return{cycles:2,instr:"bit",fixed:!1};case"call":return{cycles:6,instr:"call",class:"call",fixed:!0};case"cp":return{cycles:1,instr:"cp"};case"critical":return{cycles:16,legend:"VRAM accesses",fixed:!0};case"interrupt":return{cycles:5,legend:"Interrupt dispatch",fixed:!0};case"jr":return{cycles:2,instr:"jr",jump:!0};case"ld-imm16":return{cycles:3,instr:"ld",fixed:!0};case"ldh":return{cycles:2,instr:"ldh"};case"ldhl":return{cycles:2};case"or":return{cycles:1,instr:"or"};case"pop":return{cycles:3,instr:"pop",fixed:!0};case"push":return{cycles:4,instr:"push",fixed:!0};case"reti":return{cycles:4,instr:"reti",legend:"Return from interrupt",fixed:!0};case"set":return{cycles:2,instr:"set",fixed:!1};case"condensed":let r=a.cycles;if(typeof r!="number"||!isFinite(r))throw new SyntaxError('"Skip" CPU op requires a numeric cycle count');return{cycles:r,class:"condensed",class:"op"};default:throw new SyntaxError(`Unknown instruction type "${a.op}"`)}}();if(a.instr&&(i.instr=a.instr),a.immediate!==void 0){if(i.fixed||i.jump)throw new SyntaxError(`CPU op ${a.op} cannot be immediate!`);i.cycles++}if(a.taken!==void 0){if(!i.jump)throw new SyntaxError(`CPU op ${a.op} is not a jump, it cannot be taken!`);i.cycles++}return a.legend&&(i.legend=a.legend),i.legend&&a.io===void 0&&(i.class=a.op),a.class&&(i.class=a.class),i}},re={components:{Timeline:oe,CPUOp:H,InlineSvg:ie}},ce={class:"hint-container warning"};function de(a,s,i,r,g,A){const c=_("RouteLink"),y=_("inline-svg"),n=_("CPUOp"),p=_("Timeline");return R(),G("div",null,[s[5]||(s[5]=S('<h1 id="the-timing-of-lyc-stat-handlers" tabindex="-1"><a class="header-anchor" href="#the-timing-of-lyc-stat-handlers"><span>The Timing of LYC STAT Handlers</span></a></h1><p>Written by <a href="https://github.com/rondnelson99/" target="_blank" rel="noopener noreferrer">Ron Nelson</a> and <a href="https://eldred.fr" target="_blank" rel="noopener noreferrer">ISSOtm</a></p><hr><p>Raster effects are probably the greatest assets that retro game consoles have. The fact that the PPU generates the image right as it is displayed allows many special effects to be created by modifying the rendering parameters while the image is being drawn. Here is an example:</p><figure><p><img src="'+W+'" alt="Example of raster effect"></p></figure><p>However, unlike some consoles like the SNES, the Game Boy contains no hardware dedicated to raster effects, so the task falls squarely on the CPU. This causes raster FX code to interact with the rest of the program in complex ways, particularly when it comes to <a href="https://gbdev.io/pandocs/Accessing_VRAM_and_OAM" target="_blank" rel="noopener noreferrer">accessing VRAM</a>.</p><p>In this article, we will explore different techniques for handling raster effects, and discuss their pros and cons with the help of some diagrams.</p>',7)),l("div",ce,[s[3]||(s[3]=l("p",{class:"hint-container-title"},"PRIOR KNOWLEDGE ASSUMED",-1)),l("p",null,[s[1]||(s[1]=h("This article is not a friendly introduction to programming raster effects, and assumes you are already comfortable with Game Boy programming. To learn more about how to achieve neat raster effects like the above, check out ")),e(c,{to:"/guides/deadcscroll.html"},{default:w(()=>s[0]||(s[0]=[h("DeadCScroll")])),_:1}),s[2]||(s[2]=h(" first, which the above GIF is actually from!"))]),s[4]||(s[4]=l("p",null,[h("Additionally, since the operations discussed here are "),l("em",null,"extremely"),h(" timing-sensitive, discussions will revolve around assembly instructions. You can learn how to program for the Game Boy in assembly in "),l("a",{href:"https://eldred.fr/gb-asm-tutorial",target:"_blank",rel:"noopener noreferrer"},"GB ASM Tutorial"),h(".")],-1))]),s[6]||(s[6]=S('<div class="hint-container tip"><p class="hint-container-title">TERMINOLOGY</p><p>We&#39;ll reference a few terms throughout this tutorial; here are brief explanations of them:</p><ul><li><strong>SoC</strong>: <a href="https://en.wikipedia.org/wiki/System_on_a_chip" target="_blank" rel="noopener noreferrer">System-on-a-Chip</a>, a single chip that includes most (or all!) components of a system. The Game Boy&#39;s functionality is almost entirely contained within a single chip, confusingly labelled &quot;DMG-CPU&quot; or similar. (Contrast this with, for example, the SNES, where there is one chip for the CPU, two for the PPU, and many more.)</li><li><strong>CPU</strong>: Central Processing Unit, the part of the SoC that executes code and configures everything else.</li><li><strong>PPU</strong>: Pixel Processing Unit, the part of the SoC that is responsible for sending pixels to the LCD and generating them.</li><li><strong>Rasterization</strong>: the process of turning... something (for example, a collection of textured polygons; or, on the GB, tiles and tilemaps) into an array of pixels. &quot;Raster&quot; is sort of a contraction of that term.</li><li><strong>Scanline</strong>: a row of pixels; it&#39;s called a &quot;scan&quot;-line because the lines get drawn one by one, pixel by pixel, as if the PPU was &quot;scanning&quot; along the screen.</li><li><strong>Register</strong>: in general, a small piece of memory, usually linked to some hardware component.</li><li><strong>PPU mode</strong>: The PPU can be in one of four modes at a given time, depending on what it&#39;s doing. <a href="https://gbdev.io/pandocs/STAT" target="_blank" rel="noopener noreferrer">Please refer to Pan Docs</a> to learn what each mode corresponds to and how they are scheduled—they interact very tightly with raster effects.</li><li><strong>Interrupt</strong>: an event that gets generated. Typically, this causes a &quot;handler&quot; to be <code>call</code>ed, which is a special routine dedicated to reacting to a given interrupt.</li><li><strong>&quot;Main thread&quot;</strong>: any code that is executed outside of interrupt handlers.</li></ul></div><h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction"><span>Introduction</span></a></h2><p>The easiest way to implement raster effects is to use the <code>LYC</code> register with the STAT interrupt.</p><p>Here is what the Pan Docs have to say about this register&#39;s simple function:</p><blockquote><p><a href="https://gbdev.io/pandocs/Scrolling#ff45---lyc-ly-compare-rw" target="_blank" rel="noopener noreferrer"><strong>FF45 - LYC (LY Compare) (R/W)</strong></a></p><p>The Game Boy permanently compares the value of the LYC and LY registers. When both values are identical, the “LYC=LY” flag in the STAT register is set, and (if enabled) a STAT interrupt is requested.</p></blockquote><p>So then, the outline for setting up a raster effect is as follows:</p><ol><li>Register an interrupt by setting <code>LYC</code> to the desired scanline</li><li>When that scanline begins, the STAT interrupt handler will automatically be called</li><li>Perform your chosen effect by modifying PPU registers</li><li>Exit the handler with <code>reti</code></li></ol><div class="hint-container tip"><p class="hint-container-title">ALTERNATIVES</p><p>There are other ways to perform raster FX, such as busy-waiting in the &quot;main thread&quot;, but as this article&#39;s title suggests, we won&#39;t discuss them here.</p><p>A major pro of <code>LYC</code>-interrupt-based raster effects is that they can be made self-contained, and thus largely independent of whatever the &quot;main thread&quot; is doing. This, in turn, simplifies the mental complexity of the code (decoupling), copes better with lag frames, and more.</p><p>Many of the points brought forth later, particularly regarding cycle counting, are still relevant with these alternatives, so this is still worth reading!</p></div><p>These four steps sound simple enough on their own, but there are numerous caveats we will discuss. Strap in!</p><ul><li>Most raster effects are implemented by modifying registers <em>between</em> scanlines. Thus, you will want to write the register either during Mode 2 (of the same scanline), or Mode 0 (of the previous one)—anything but Mode 3, really.<br> Unfortunately, <code>LY=LYC</code> interrupts are requested at the beginning of a scanline, so during the very short Mode 2, leaving too little time to perform but the most basic of effects.</li><li>Writing to the register during HBlank instead implies triggering the interrupt on the scanline <em>above</em> the effect, as well as idling for most of the scanline. So, if I wanted to enable sprites on scanline 16, I&#39;d write 15 to <code>LYC</code>.</li><li>Mode 3&#39;s length is variable, so syncing to HBlank is difficult and time-consuming.</li><li>The interrupt handler&#39;s execution may be delayed by a few cycles, which makes it difficult to reliably sync to the PPU.</li><li>If the &quot;main thread&quot; is itself trying to sync with the PPU (typically by polling <code>STAT</code> in a loop), our interrupt may throw off its timing.</li></ul><p>Sounds good? Then let&#39;s get started!</p><h2 id="timing" tabindex="-1"><a class="header-anchor" href="#timing"><span>Timing</span></a></h2><p>First, let&#39;s look at the timing of the rendering itself, <a href="https://gbdev.io/pandocs/pixel_fifo" target="_blank" rel="noopener noreferrer">courtesy of the Pan Docs</a>:</p>',13)),e(y,{src:"/images/ppu_modes_timing.svg",viewBox:"0 0 700 307",style:{"--fg":"var(--c-text)"}}),s[7]||(s[7]=S(`<p>Here are some key points:</p><ul><li>A &quot;dot&quot; is one period of the PPU&#39;s 4 MiHz clock, i.e. 0.25 µs.</li><li>A &quot;cycle&quot; is the main unit of time in the CPU, which is equal to 1 µs, or 4 dots. (The Game Boy Color CPU can enter a &quot;double-speed&quot; mode which halves the length of cycles, but not of dots. For the sake of simplicity, we won&#39;t consider the differences it involves here.)</li><li>Each scanline takes exactly 456 dots, or 114 cycles.</li><li>Mode 2 also takes a constant amount of time (20 cycles)</li><li>HBlank&#39;s length varies wildly, and will often be nearly as long as or longer than the drawing phase.</li><li>HBlank and OAM scan are mostly interchangeable, and long as you&#39;re not writing to OAM.</li><li>The worst-case HBlank&#39;s length is not a multiple of 4 dots, so we will round down to 21 cycles.</li></ul><p>Let&#39;s consider a simple STAT handler, which disables OBJs if called at line 128, and enables them otherwise:</p><div class="language-asm line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="asm"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff;"><code><span class="line"><span class="line"><span style="color:#88C0D0;">LYC</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;">:</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    push</span><span style="color:#D8DEE9FF;"> af</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rLY]</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    cp </span><span style="color:#B48EAD;">128</span><span style="color:#D8DEE9FF;"> - </span><span style="color:#B48EAD;">1</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    jr z, .disableSprites</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">    ; enable sprites</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rLCDC]</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    or</span><span style="color:#D8DEE9FF;"> a, LCDCF_OBJON</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh [rLCDC], a</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    pop</span><span style="color:#D8DEE9FF;"> af</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    reti</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">.disableSprites</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rLCDC]</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    and</span><span style="color:#D8DEE9FF;"> a, ~LCDCF_OBJON</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh [rLCDC], a</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    pop</span><span style="color:#D8DEE9FF;"> af</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    reti</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>This is not an especially well-written <code>STAT</code> handler, but the actual is outside the scope of this tutorial. If that&#39;s what you&#39;re looking for, check out <a href="deadcscroll">DeadCScroll</a> by Blitter Object. It triggers the STAT interrupt on HBlanks rather than <code>LYC</code>, but the fundamentals are the same.</p><p>Note that, for simplicity&#39;s sake, DeadCScroll does not consider the problems described further below, so be wary of combining that tutorial&#39;s STAT handler unmodified with <code>STAT</code>-based VRAM accesses in the main thread.</p></div><p>Let&#39;s assume that the interrupt fires at, say, scanline 42. Equipped with <a href="https://gbdev.io/gb-opcodes/optables" target="_blank" rel="noopener noreferrer">the GB instruction table</a> (see its legend at the bottom), we can plot how many cycles each operation takes, in relation with the PPU&#39;s mode:</p>`,6)),e(p,{offset:0,asmFile:"lyc_timing/simple_handler.asm"},{default:w(()=>[e(n,{op:"interrupt"}),e(n,{line:2}),e(n,{line:3,immediate:""}),e(n,{line:4,immediate:""}),e(n,{line:5}),e(n,{line:8,immediate:""}),e(n,{line:9,immediate:""}),e(n,{line:10,immediate:"",io:"",legend:"Write to LCDC"}),e(n,{line:11}),e(n,{line:12})]),_:1}),s[8]||(s[8]=S(`<p>The first 5 cycles do not have an instruction: indeed, calling an interrupt handler is not instantaneous, and the CPU is temporarily busy pushing the program counter (<code>PC</code>) to the stack, disabling interrupts, etc. Then, the actual interrupt handler begins execution.</p><p>We can immediately spot a problem: the cycle during which <code>LCDC</code> is written to falls in the middle of rendering! (With only a handful of exceptions, instructions that access memory do so on their very last cycle.) This is usually undesirable, and could lead to graphical glitches like an OBJ being partially cut off until we write to <code>LCDC</code>.</p><p>Another problem, less obvious but oh so painful, is how the interrupt handler might interact with the &quot;main thread&quot;&#39;s operation.</p><h3 id="the-vram-access-race-condition" tabindex="-1"><a class="header-anchor" href="#the-vram-access-race-condition"><span>The VRAM access <a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="noopener noreferrer">race condition</a></span></a></h3><p>Accessing VRAM <a href="https://gbdev.io/pandocs/Accessing_VRAM_and_OAM" target="_blank" rel="noopener noreferrer">is not possible during Mode 3</a>. Thus, when we want to access VRAM, precautions must be taken; the most common is to use the following loop:</p><div class="language-asm line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="asm"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff;"><code><span class="line"><span class="line"><span style="color:#D8DEE9FF;">.waitVRAM</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">	ldh a, [rSTAT]</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">	and</span><span style="color:#D8DEE9FF;"> STATF_BUSY </span><span style="color:#616E88;">; 2</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">	jr nz, .waitVRAM</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This loop checks whether <code>[STAT] &amp; 2</code> is zero, and exits when it does. Looking at <a href="https://gbdev.io/pandocs/STAT#ff41---stat-lcd-status-rw" target="_blank" rel="noopener noreferrer">documentation for <code>STAT</code></a>, we can see that the lowest 2 bits report the PPU&#39;s mode, and that <code>[STAT] &amp; 2</code> is zero for Mode 0 and Mode 1, but not Mode 2 or Mode 3. So, essentially, this loop waits for Mode 0 or Mode 1, which are both safe to write to VRAM—but it can&#39;t be that simple.</p>`,7)),e(p,{offset:111,asmFile:"lyc_timing/stat_loop.asm"},{default:w(()=>[e(n,{line:2,immediate:"",io:"",legend:"Read from STAT"}),e(n,{line:3,immediate:""}),e(n,{line:4}),e(n,{op:"critical"}),e(n,{op:"condensed",cycles:2})]),_:1}),s[9]||(s[9]=l("p",null,[h('Pictured above is the "worst case" for this loop. As you can see, on the cycle that '),l("code",null,"STAT"),h(" is read, the PPU is still in Mode 0; however, checking for it takes a few cycles, during which we enter Mode 2!")],-1)),s[10]||(s[10]=l("p",null,[h("Now, thankfully, Mode 2 is "),l("em",null,"also"),h(' safe for accessing VRAM—but only 16 cycles of it remain. This is why this loop is said to guarantee 16 "VRAM-safe" cycles: any access performed 17 cycles or more after it would break in this worst case.')],-1)),s[11]||(s[11]=l("p",null,"Now, what would happen if our interrupt was requested in the middle of this?",-1)),e(p,{offset:111,asmFile:"lyc_timing/simple_handler.asm"},{default:w(()=>[e(n,{instr:"ldh a, [rSTAT]",immediate:"",io:"",legend:"Read from STAT"}),e(n,{op:"interrupt"}),e(n,{line:2}),e(n,{line:3,immediate:""}),e(n,{line:4,immediate:""}),e(n,{line:5}),e(n,{line:8,immediate:""}),e(n,{line:9,immediate:""}),e(n,{line:10,immediate:""}),e(n,{line:11}),e(n,{line:12}),e(n,{instr:"and STATF_BUSY",immediate:""}),e(n,{instr:"jr nz, .waitVRAM"}),e(n,{op:"critical"})]),_:1}),s[12]||(s[12]=l("p",null,"Oh no! The main thread is now trying to access VRAM right in the middle of Mode 3! This could lead to all sorts of visual bugs.",-1)),s[13]||(s[13]=l("h3",{id:"a-solution",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#a-solution"},[l("span",null,"A solution?")])],-1)),s[14]||(s[14]=l("p",null,[h("The solution is not too complicated, at least on paper. We should be able to use the same "),l("code",null,"STAT"),h("-checking loop (or at least, a variation of it) inside of the handler. It works in the main thread, so it should work here as well, right?")],-1)),s[15]||(s[15]=l("p",null,[h("Remember that many "),l("code",null,"STAT"),h(" handlers will be much more complicated than the simple example above, so let's draw a diagram with an imaginary handler that would take significantly more time:")],-1)),e(p,{offset:111},{default:w(()=>[e(n,{instr:"ldh a, [rSTAT]",immediate:"",io:"",legend:"Read from STAT"}),e(n,{op:"interrupt"}),e(n,{op:"condensed",cycles:92}),e(n,{instr:"ldh a, [rSTAT]",immediate:""}),e(n,{instr:"and STATF_BUSY",immediate:""}),e(n,{instr:"jr nz, .handlerWait"}),e(n,{instr:"(Write to LCDC)",op:"ldhl",immediate:""}),e(n,{instr:"pop hl"}),e(n,{instr:"pop af"}),e(n,{instr:"reti"}),e(n,{instr:"and STATF_BUSY",immediate:""}),e(n,{instr:"jr nz, .waitVRAM"}),e(n,{op:"critical"})]),_:1}),s[16]||(s[16]=S(`<div class="hint-container tip"><p class="hint-container-title">Tips</p><p>All the instructions between the &quot;Interrupt dispatch&quot; and &quot;Return from interrupt&quot; blocks are the interrupt handler, the rest is in the &quot;main thread&quot;.</p></div><p>The <code>STAT</code> loop does fix the register being written to during Mode 3; however, once again, the 16 cycles that &quot;main thread&quot; expects to be VRAM-safe overlap with Mode 3. The problem here is that the write, <code>pop</code> and <code>reti</code> all take some of those cycles, and the &quot;main thread&quot; is using the value it read from <code>STAT</code> during the previous scanline—but that value is now stale.</p><h3 id="possible-fixes" tabindex="-1"><a class="header-anchor" href="#possible-fixes"><span>Possible fixes</span></a></h3><p>Using what we have learned so far, we can boil down the problem to three factors:</p><ol><li>Our handler can trigger in the middle of this sequence of events</li><li>Our handler preserves the stale value read from <code>STAT</code> earlier</li><li>Our handler returns during a time where accessing VRAM is unsafe</li></ol><p>It would be enough to get rid of <em>any</em> of these, so let&#39;s enumerate our options.</p><h4 id="dealing-with-it" tabindex="-1"><a class="header-anchor" href="#dealing-with-it"><span>Dealing with it</span></a></h4><p>It&#39;s entirely possible to accept the loss of some of those cycles. This amounts to assuming less than the usual 16 cycles after such loops. For example, putting a <code>STAT</code>-polling loop just before the last <code>pop af</code> and <code>reti</code> would have these two eat up 7 cycles, so we are down to 9.</p><p>This will quickly become impractical, requiring syncing to the LCD much more often in the main thread.</p><h4 id="handler-timing" tabindex="-1"><a class="header-anchor" href="#handler-timing"><span>Handler timing</span></a></h4><p>A simple way to prevent those pesky handlers from throwing off our timing is to disable them, with the <code>di</code> instruction. Unfortunately, it can&#39;t quite be so simple, as using <code>di</code> for this brings its own share of problems.</p><p>The most important one is that disabling the handlers like this <em>delays</em> their execution! <code>STAT</code> handlers designed to write to hardware regs during HBlank may start doing so during rendering instead; timer interrupts won&#39;t trigger as regularly now; and so on.</p><p>Using <code>di</code> is valid in some cases, but typically not when <code>STAT</code> interrupts are involved, due to their fairly strict timing requirements.</p><p>An oddly common alternative is to perform all VRAM updates in VBlank handler. (The reason why it&#39;s common especially in early GB games is likely being a carry-over from the NES, where the lack of HBlanks essentially mandates such a setup anyway.) While this can work, such as for <em>Metroid II</em>, it requires significant complexity from having to keep deferring graphical updates.</p><h4 id="stale-stat-read" tabindex="-1"><a class="header-anchor" href="#stale-stat-read"><span>Stale <code>STAT</code> read</span></a></h4><p>There is not much that can be done about this one. The interrupt handler <em>must</em> preserve registers, and ...</p><p>TOCTTOU</p><h4 id="return-timing" tabindex="-1"><a class="header-anchor" href="#return-timing"><span>Return timing</span></a></h4><p>This is the solution that the rest of this article will explore, as we will see that it makes the least painful compromises out of most use cases.</p><p>So, the real solution is to fully exit before the end of HBlank. There are two ways to do this. One is to wait for the Drawing phase before waiting for HBlank. This effectively catches the very start of HBlank, leaving plenty of time to exit. Here&#39;s how the earlier example might look using this method:</p><div class="language-asm line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="asm"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff;"><code><span class="line"><span class="line"><span style="color:#88C0D0;">LYC</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;">:</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    push</span><span style="color:#D8DEE9FF;"> af</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    push</span><span style="color:#D8DEE9FF;"> hl</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rLY]</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    cp </span><span style="color:#B48EAD;">128</span><span style="color:#D8DEE9FF;"> - </span><span style="color:#B48EAD;">1</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    jr z, .disableSprites</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">    ; enable sprites</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rLCDC]</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    or</span><span style="color:#D8DEE9FF;"> a, LCDCF_OBJON</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    jr .finish</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">.disableSprites</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rLCDC]</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    and</span><span style="color:#D8DEE9FF;"> a, ~LCDCF_OBJON</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">.finish</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ld hl, rSTAT</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">.waitNotBlank</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    bit STATB_BUSY, [hl]</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    jr z, .waitNotBlank</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">.waitBlank</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    bit STATB_BUSY, [hl]</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    jr nz, .waitBlank</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh [rLCDC], a</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    pop</span><span style="color:#D8DEE9FF;"> hl</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    pop</span><span style="color:#D8DEE9FF;"> af</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    reti</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>See how this method never interferes with VRAM accesses in the main thread, even with the worst possible timing and the shortest of HBlanks:</p>`,22)),e(p,{offset:111,"hblank-length":21,asmFile:"lyc_timing/ret_hblank_handler.asm"},{default:w(()=>[e(n,{instr:"ldh a, [rSTAT]",immediate:""}),e(n,{op:"interrupt"}),e(n,{line:2}),e(n,{line:3}),e(n,{line:4,immediate:""}),e(n,{line:5,immediate:""}),e(n,{line:6}),e(n,{line:9,immediate:""}),e(n,{line:10,immediate:""}),e(n,{line:11,taken:""}),e(n,{line:18,op:"ld-imm16"}),e(n,{line:20,immediate:"",io:"",legend:"STAT is tested"}),e(n,{line:21}),e(n,{line:23,immediate:"",io:"",legend:"STAT is tested"}),e(n,{line:24,taken:""}),e(n,{op:"condensed",cycles:42}),e(n,{line:23,immediate:"",io:"",legend:"STAT is tested"}),e(n,{line:24,taken:""}),e(n,{line:23,immediate:"",io:"",legend:"STAT is tested"}),e(n,{line:24,taken:""}),e(n,{line:23,immediate:"",io:"",legend:"STAT is tested"}),e(n,{line:24}),e(n,{line:26,immediate:""}),e(n,{line:27}),e(n,{line:28}),e(n,{line:29}),e(n,{instr:"and STATF_BUSY",immediate:""}),e(n,{instr:"jr nz, .waitVRAM"}),e(n,{op:"condensed",cycles:16,class:"critical",legend:"VRAM accesses"})]),_:1}),s[17]||(s[17]=l("p",null,"Phew! This just barely works. There are only two cycles to spare! If there were multiple registers that needed updating, you might run into trouble. Normally, These really short HBlanks are the worst-case scenario that you always fear. However, in practice, HBlanks are normally much longer, often even longer than the drawing phase. Using this method, that can actually have unfortunate consequences:",-1)),e(p,{offset:111,"hblank-length":51,asmFile:"lyc_timing/ret_hblank_handler.asm"},{default:w(()=>[e(n,{instr:"ldh a, [rSTAT]",immediate:""}),e(n,{op:"interrupt"}),e(n,{line:2}),e(n,{line:3}),e(n,{op:"condensed",cycles:46}),e(n,{line:18,op:"ld-imm16"}),e(n,{line:20,immediate:"",io:"",legend:"STAT is tested"}),e(n,{line:21,taken:""}),e(n,{op:"condensed",cycles:48}),e(n,{line:20,immediate:"",io:"",legend:"STAT is tested"}),e(n,{line:21}),e(n,{line:23,immediate:"",io:"",legend:"STAT is tested"}),e(n,{line:24,taken:""}),e(n,{op:"condensed",cycles:48}),e(n,{line:23,immediate:"",io:"",legend:"STAT is tested"}),e(n,{line:24}),e(n,{line:26,immediate:""}),e(n,{line:27}),e(n,{line:28}),e(n,{line:29}),e(n,{instr:"and STATF_BUSY",immediate:""}),e(n,{instr:"jr nz, .waitVRAM"}),e(n,{op:"condensed",cycles:16,class:"critical",legend:"VRAM accesses"})]),_:1}),s[18]||(s[18]=S(`<p>This time, when all the processing was done, there was still plenty of time left in the scanline to safely exit. However, since HBlank was so long, the routine missed the check for the drawing window and wasted an entire scanline waiting for that Drawing -&gt; HBlank transition before it exited. Not only does this waste precious CPU time, but it also limits how often raster FX can be used throughout the frame. This method still works fine though, and can be an easy approach if you use Raster FX sparingly.</p><p>I&#39;m a bit of a perfectionist, so I usually like to strive for the absolute best method. In a perfect world, we would precisely know whether we have enough HBlank left to safely exit. There actually is a way to do that though! You just need to count exactly how long your routine takes, and make sure it always exits during HBlank. This comes with some caveats though. Most routines, if they haven&#39;t been specifically designed for this method, will take a variable amount of time. The main things you need to avoid are <code>if</code> statements and loops. Specifically, if statements of this form are problematic:</p><div class="language-asm line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="asm"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff;"><code><span class="line"><span class="line"><span style="color:#616E88;">    ; test a condition here...</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    jr nc, .skip </span><span style="color:#616E88;">; skip the next part unless Carry is set</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">    ; do something here, only if the previous operation set Carry</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">.skip</span></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">    ; continue on with the program.</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The problem here is that the code following this pattern may be run after a variable number of cycles have passed. If you need to use an if statement, always make it an if/else statement so that you can waste cycles in the <code>else</code> portion and take the same number of cycles.</p><p>So now that you&#39;re ready to count the cycles of your handler, how long do you need to make the routine? Let&#39;s look at some more diagrams to figure this out!</p>`,5)),e(p,{offset:111},{default:w(()=>[e(n,{instr:"ldh a, [rSTAT]",immediate:"",io:"",legend:"STAT read"}),e(n,{op:"interrupt"}),e(n,{op:"condensed",cycles:105}),e(n,{instr:"reti"}),e(n,{instr:"and STATF_BUSY",immediate:""}),e(n,{instr:"jr nz, .waitVRAM"}),e(n,{op:"condensed",cycles:16,class:"critical",legend:"VRAM accesses"})]),_:1}),s[19]||(s[19]=l("p",null,[h("Wow! That's a lot of cycles! Here, the routine takes exactly one scanline to complete, so the main thread does its writes at the same moment on the next scanline, with no idea what happened! If you count up all the cyan cycles, you'll see that there are 105 of them, and 109 if you count the "),l("code",null,"reti"),h(". This extra time makes it possible to write to two or three registers safely, rather than just one. If you don't need all that time, you can make it shorter as well:")],-1)),e(p,{offset:107,"hblank-length":21},{default:w(()=>[e(n,{instr:"ldh a, [rSTAT]",immediate:"",io:"",legend:"STAT read"}),e(n,{instr:"and STATF_BUSY",immediate:""}),e(n,{instr:"jr nz, .waitVRAM"}),e(n,{op:"interrupt"}),e(n,{op:"condensed",cycles:84}),e(n,{instr:"reti"}),e(n,{op:"condensed",cycles:16,class:"critical",legend:"VRAM accesses"})]),_:1}),s[20]||(s[20]=l("p",null,[h("This time, I put the "),l("code",null,"and"),h(" and "),l("code",null,"jr"),h(" before the interrupt, so that when it resumes, it's all ready to start writing to VRAM. This interrupt routine is 87 cycles long, including the "),l("code",null,"reti"),h(". This won't often prove especially useful though, because you never take any time during HBlank to actually do any register writes. However, you could use this if your routine has a case where it realizes that nothing actually needs to be written, and you can exit earlier.")],-1)),s[21]||(s[21]=l("p",null,[h("From those two diagrams, you'll see that the 22 cycles of worst-case HBlank is the time you can use to write to any PPU registers, pop your registers back, and then exit with "),l("code",null,"reti"),h(". These 22 cycles are cycle 88 through cycle 109, inclusive.")],-1)),s[22]||(s[22]=l("p",null,"What if I told you that you could actually have your handler take only 86 cycles? Well, you can!",-1)),e(p,{offset:107,"hblank-length":21},{default:w(()=>[e(n,{instr:"ldh a, [rSTAT]",immediate:"",io:"",legend:"STAT read"}),e(n,{instr:"and STATF_BUSY",immediate:""}),e(n,{instr:"jr nz, .waitVRAM"}),e(n,{op:"interrupt"}),e(n,{op:"condensed",cycles:83}),e(n,{instr:"reti"}),e(n,{op:"condensed",cycles:16,class:"critical",legend:"VRAM accesses"})]),_:1}),s[23]||(s[23]=l("p",null,"This seems bad, since the first cycle of the red bar, where the main thread may try to access VRAM, is potentially during the Drawing phase! This is also fine though. All instructions that access memory, whether through an immediate address or using a register pair as a pointer, take multiple cycles to complete. That's because the first cycle of every instruction is used to fetch the operation code itself. The memory access that the instruction performs is always in the 2nd, 3rd or 4th cycle of the instruction. In this situation, the 2nd cycle of the VRAM-accessible time is in HBlank, so this won't actually cause any problems.",-1)),s[24]||(s[24]=l("h2",{id:"but-wait",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#but-wait"},[l("span",null,"But Wait!")])],-1)),s[25]||(s[25]=l("p",null,"The interrupt latency I showed earlier doesn't actually tell the full story. Before it even starts to service the interrupt, the system waits for the current instruction to finish. This is how that might look with the longest allowable routine:",-1)),e(p,{offset:106,"hblank-length":51},{default:w(()=>[e(n,{instr:"ldh a, [rSTAT]",immediate:"",io:"",legend:"STAT read"}),e(n,{instr:"and STATF_BUSY",immediate:""}),e(n,{instr:"jr nz, .waitVRAM"}),e(n,{instr:"call SomeFunc"}),e(n,{op:"interrupt"}),e(n,{op:"condensed",cycles:105}),e(n,{instr:"reti"}),e(n,{op:"condensed",cycles:10,class:"critical",legend:"VRAM accesses"})]),_:1}),s[26]||(s[26]=S(`<p>Here, the first green block shows the system waiting 5 cycles for a <code>call</code> instruction to finish. <code>call</code> is the longest instruction at 6 cycles, so if the interrupt is requested just after it begins, the system will wait 5 cycles for it to complete. This seems bad, since the routine exited after the end of HBlank. However, this is actually fine! Those waiting cycles were not wasted; they were still 5 cycles of work that the main thread got done. So in the end, the main thread still gets its 20 cycles of VRAM-accessible time.</p><h2 id="pros-and-cons" tabindex="-1"><a class="header-anchor" href="#pros-and-cons"><span>Pros and Cons</span></a></h2><p>Thus far, I have presented two very different methods for making safe <code>LYC</code> handlers, and each have their pros and cons.</p><h2 id="double-busy-loop" tabindex="-1"><a class="header-anchor" href="#double-busy-loop"><span>Double-Busy-Loop</span></a></h2><p><strong>Pros</strong></p><ul><li>does not require all code to be constant-time</li><li>does not require tedious cycle-counting</li><li>may exit very early if the routine finishes quickly</li></ul><p><strong>Cons</strong></p><ul><li>does not provide enough HBlank time to safely write multiple registers</li><li>if the routine takes too long, it may miss mode 3 and waste an entire scanline before exiting</li></ul><h2 id="cycle-counting" tabindex="-1"><a class="header-anchor" href="#cycle-counting"><span>Cycle-counting</span></a></h2><p><strong>Pros</strong></p><ul><li>leaves more time for more complex logic in the routine</li><li>allows enough time during blanking to write to up to three registers</li><li>never takes longer than one scanline</li></ul><p><strong>Cons</strong></p><ul><li>requires all code to be constant-time</li><li>requires tedious cycle-counting</li><li>always takes close to an entire scanline, even if HBlank starts much sooner</li></ul><p>This suggests that the double-busy-loop method is good for extremely simple <code>LYC</code> routines that only need to write to one register, or routines that for some reason cannot be cycle-counted. If you need more time for calculations and more time to write to those registers, you can cycle-count your routine.</p><p>But what if you could combine both these methods? Enter the <strong>Hybrid Cycle-Counted Handler™</strong>, a technique I came up with while writing this document.</p><h2 id="combining-approaches" tabindex="-1"><a class="header-anchor" href="#combining-approaches"><span>Combining Approaches</span></a></h2><p>The goal of this method is to combine the maximum HBlank time that cycle-counting delivers, while still exiting early when HBlank is longer. Here is an example. If you&#39;ve read <a href="deadcscroll">DeadCScroll</a>, you&#39;ll recognise this as that tutorial&#39;s <code>STAT</code> Handler, modified to start at Mode 2 rather than HBlank, and be safe towards VRAM accesses in the main thread.</p><div class="language-asm line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="asm"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff;"><code><span class="line"><span class="line"><span style="color:#81A1C1;">    push</span><span style="color:#D8DEE9FF;"> af </span><span style="color:#616E88;">; 4</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    push</span><span style="color:#D8DEE9FF;"> hl </span><span style="color:#616E88;">; 8</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">    ; obtain the pointer to the data pair</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rLY] </span><span style="color:#616E88;">; 11</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    inc</span><span style="color:#D8DEE9FF;"> a </span><span style="color:#616E88;">; 12</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    add</span><span style="color:#D8DEE9FF;"> a, a </span><span style="color:#616E88;">; 13 ; double the offset since each line uses 2 bytes</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ld l, a </span><span style="color:#616E88;">; 14</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh a, [hDrawBuffer] </span><span style="color:#616E88;">; 17</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    adc</span><span style="color:#B48EAD;"> 0</span><span style="color:#616E88;"> ; 19</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ld h, a </span><span style="color:#616E88;">; 20 ; hl now points to somewhere in the draw buffer</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    call</span><span style="color:#D8DEE9FF;"> UnconditionalRet </span><span style="color:#616E88;">; just waste 31 cycles while we wait for HBlank to maybe start</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    call</span><span style="color:#D8DEE9FF;"> UnconditionalRet</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    call</span><span style="color:#D8DEE9FF;"> UnconditionalRet</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    nop</span><span style="color:#616E88;"> ; 51</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">    ; now start trying to look for HBlank to exit early</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rSTAT]</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    and</span><span style="color:#D8DEE9FF;"> STATF_BUSY</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    jr z, .setAndExit </span><span style="color:#616E88;">; 58</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rSTAT]</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    and</span><span style="color:#D8DEE9FF;"> STATF_BUSY</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    jr z, .setAndExit </span><span style="color:#616E88;">; 65</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rSTAT]</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    and</span><span style="color:#D8DEE9FF;"> STATF_BUSY</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    jr z, .setAndExit </span><span style="color:#616E88;">; 72</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rSTAT]</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    and</span><span style="color:#D8DEE9FF;"> STATF_BUSY</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    jr z, .setAndExit </span><span style="color:#616E88;">; 79</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    nop</span><span style="color:#616E88;"> ; waste 4 more cycles since there isn&#39;t time for another check</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    nop</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    nop</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    nop</span><span style="color:#616E88;"> ; 83</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">.setAndExit</span></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">    ; set the scroll registers</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ld a,[hl+] </span><span style="color:#616E88;">; 85</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh [rSCY],a </span><span style="color:#616E88;">; 88</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ld a,[hl+] </span><span style="color:#616E88;">; 90</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    ldh [rSCX],a </span><span style="color:#616E88;">; 93</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    pop</span><span style="color:#D8DEE9FF;"> hl </span><span style="color:#616E88;">; 97</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    pop</span><span style="color:#D8DEE9FF;"> af </span><span style="color:#616E88;">; 100</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    reti </span><span style="color:#616E88;">; 104</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Once the handler finishes its logic, the handler delays cycles until it reaches the window then HBlank might start. With a 5-cycle offset due to a <code>call</code>, and the longest possible HBlank, the earliest HBlank might start is cycle 54, so that&#39;s the first attempt to read <code>STAT</code>. It keeps checking <code>STAT</code> until even in the worst-case scenario, it knows that HBlank will start. Then, it uses that time to write the scroll registers and exit. This way, it can still exit early, as long as the HBlank length permits. This routine takes 104 cycles in the worst-case scenario, but may take as few as 79 if HBlank comes sooner.</p><p>The reason that the double-busy-loop method requires checking for Mode 3 but this method does not is that the double-busy-loop method is not cycle-counted, so you might be at the very end of HBlank which is problematic. Since this method is cycle-counted, you know that if HBlank has begun, you are at or near the start of it.</p><p>If we make a similar list of pros and cons for this method, this is what it might look like:</p><h2 id="hybrid-cycle-counting" tabindex="-1"><a class="header-anchor" href="#hybrid-cycle-counting"><span>Hybrid cycle-counting</span></a></h2><p><strong>Pros</strong></p><ul><li>may exit very early if HBlank is longer</li><li>allows enough time during blanking to write to up to three registers</li><li>never takes longer than one scanline</li></ul><p><strong>Cons</strong></p><ul><li>requires all code to be constant-time</li><li>requires tedious cycle-counting</li></ul><p>This method can work well in many circumstances, and is especially suited to frequent effects that modify multiple registers and need to exit quickly to avoid taking too much CPU time. This method can even work reasonably well when used on every scanline through the Mode 2 interrupt.</p><p>All three of these methods can generate great-looking effects, but I think the third one is an especially attractive option.</p><p>Congrats! You made it to the end of the tutorial! I bet you&#39;re tired of reading it, and I&#39;m tired of writing it too. So thanks for reading, see you next time!</p>`,29))])}const ue=$(re,[["render",de]]),me=JSON.parse('{"path":"/guides/lyc_timing.html","title":"The Timing of LYC STAT Handlers","lang":"en-US","frontmatter":{"head":[["meta",{"name":"og:title","content":"Timing of LYC STAT Handlers"}],["meta",{"name":"og:description","content":"Guide on how to implement raster effects with the rLYC register."}]]},"headers":[{"level":2,"title":"Introduction","slug":"introduction","link":"#introduction","children":[]},{"level":2,"title":"Timing","slug":"timing","link":"#timing","children":[{"level":3,"title":"The VRAM access race condition","slug":"the-vram-access-race-condition","link":"#the-vram-access-race-condition","children":[]},{"level":3,"title":"A solution?","slug":"a-solution","link":"#a-solution","children":[]},{"level":3,"title":"Possible fixes","slug":"possible-fixes","link":"#possible-fixes","children":[]}]},{"level":2,"title":"But Wait!","slug":"but-wait","link":"#but-wait","children":[]},{"level":2,"title":"Pros and Cons","slug":"pros-and-cons","link":"#pros-and-cons","children":[]},{"level":2,"title":"Double-Busy-Loop","slug":"double-busy-loop","link":"#double-busy-loop","children":[]},{"level":2,"title":"Cycle-counting","slug":"cycle-counting","link":"#cycle-counting","children":[]},{"level":2,"title":"Combining Approaches","slug":"combining-approaches","link":"#combining-approaches","children":[]},{"level":2,"title":"Hybrid cycle-counting","slug":"hybrid-cycle-counting","link":"#hybrid-cycle-counting","children":[]}],"git":{"contributors":[{"name":"bbbbbr","username":"bbbbbr","email":"bbbbbr@users.noreply.github.com","commits":1,"url":"https://github.com/bbbbbr"}],"changelog":[{"hash":"fb3483da82d5822bea38e28cd77cdaf10782003d","time":1748088495000,"email":"bbbbbr@users.noreply.github.com","author":"bbbbbr","message":"gbcompo25: fill prize TODOs, update examples to match itch io (#95)"}]},"filePathRelative":"guides/lyc_timing.md"}');export{ue as comp,me as data};
