<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.32">
    <meta name="og:title" content="Timing of LYC STAT Handlers"><meta name="og:description" content="Guide on how to implement raster effects is with the rLYC register."><link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png"><meta property="og:site_name" content="gbdev.io"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@gbdev0"><meta name="og:image" content="https://gbdev.io/images/gbinternals.png"><title>The Timing of LYC STAT Handlers | gbdev</title><meta name="description" content="game boy development scene">
    <link rel="modulepreload" href="/assets/app.4be7e843.js"><link rel="modulepreload" href="/assets/lyc_timing.html.88f53337.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/lyc_timing.html.1bcabf60.js">
    <link rel="stylesheet" href="/assets/style.10e6e5cf.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">gbdev</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a class="external-link" href="https://hh.gbdev.io" rel="noopener noreferrer" target="_blank" aria-label="Games"><!--[--><!--]--> Games <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://gbdev.io/pandocs" rel="noopener noreferrer" target="_blank" aria-label="Pan Docs"><!--[--><!--]--> Pan Docs <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://www.getrevue.co/profile/gbdev" rel="noopener noreferrer" target="_blank" aria-label="Newsletter"><!--[--><!--]--> Newsletter <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Community"><span class="title">Community</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Community"><span class="title">Community</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/chat" class="" aria-label="Chat"><!--[--><!--]--> Chat <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/contribute" class="" aria-label="Contribute"><!--[--><!--]--> Contribute <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/gbcompo21" class="" aria-label="GB Competition 2021"><!--[--><!--]--> GB Competition 2021 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a href="/resources" class="" aria-label="Resources"><!--[--><!--]--> Resources <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Guides"><span class="title">Guides</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Guides"><span class="title">Guides</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/guides/tools" class="" aria-label="Choosing development tools"><!--[--><!--]--> Choosing development tools <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/guides/asmstyle" class="" aria-label="ASM Style recomendations"><!--[--><!--]--> ASM Style recomendations <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/guides/lyc_timing" class="router-link-active" aria-label="The Timing of LYC STAT Handlers"><!--[--><!--]--> The Timing of LYC STAT Handlers <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/guides/deadcscroll" class="" aria-label="Dead C Scroll"><!--[--><!--]--> Dead C Scroll <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://eldred.fr/blog/2022/05/22/prehistorik" rel="noopener noreferrer" target="_blank" aria-label="The wonders of Prehistorik Man"><!--[--><!--]--> The wonders of Prehistorik Man <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/guides/dma_hijacking" class="" aria-label="DMA Hijacking"><!--[--><!--]--> DMA Hijacking <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://eldred.fr/gb-asm-tutorial" rel="noopener noreferrer" target="_blank" aria-label="GB ASM Programming Guide"><!--[--><!--]--> GB ASM Programming Guide <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a class="external-link" href="https://hh.gbdev.io" rel="noopener noreferrer" target="_blank" aria-label="Games"><!--[--><!--]--> Games <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://gbdev.io/pandocs" rel="noopener noreferrer" target="_blank" aria-label="Pan Docs"><!--[--><!--]--> Pan Docs <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://www.getrevue.co/profile/gbdev" rel="noopener noreferrer" target="_blank" aria-label="Newsletter"><!--[--><!--]--> Newsletter <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Community"><span class="title">Community</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Community"><span class="title">Community</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/chat" class="" aria-label="Chat"><!--[--><!--]--> Chat <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/contribute" class="" aria-label="Contribute"><!--[--><!--]--> Contribute <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/gbcompo21" class="" aria-label="GB Competition 2021"><!--[--><!--]--> GB Competition 2021 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a href="/resources" class="" aria-label="Resources"><!--[--><!--]--> Resources <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Guides"><span class="title">Guides</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Guides"><span class="title">Guides</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/guides/tools" class="" aria-label="Choosing development tools"><!--[--><!--]--> Choosing development tools <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/guides/asmstyle" class="" aria-label="ASM Style recomendations"><!--[--><!--]--> ASM Style recomendations <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/guides/lyc_timing" class="router-link-active" aria-label="The Timing of LYC STAT Handlers"><!--[--><!--]--> The Timing of LYC STAT Handlers <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/guides/deadcscroll" class="" aria-label="Dead C Scroll"><!--[--><!--]--> Dead C Scroll <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://eldred.fr/blog/2022/05/22/prehistorik" rel="noopener noreferrer" target="_blank" aria-label="The wonders of Prehistorik Man"><!--[--><!--]--> The wonders of Prehistorik Man <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/guides/dma_hijacking" class="" aria-label="DMA Hijacking"><!--[--><!--]--> DMA Hijacking <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://eldred.fr/gb-asm-tutorial" rel="noopener noreferrer" target="_blank" aria-label="GB ASM Programming Guide"><!--[--><!--]--> GB ASM Programming Guide <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p class="sidebar-item sidebar-heading">The Timing of LYC STAT Handlers <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/guides/lyc_timing.html#introduction" class="router-link-active router-link-exact-active sidebar-item" aria-label="Introduction"><!--[--><!--]--> Introduction <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/guides/lyc_timing.html#timing" class="router-link-active router-link-exact-active sidebar-item" aria-label="Timing"><!--[--><!--]--> Timing <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/guides/lyc_timing.html#the-vram-access-race-condition" class="router-link-active router-link-exact-active sidebar-item" aria-label="The VRAM access race condition"><!--[--><!--]--> The VRAM access race condition <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/guides/lyc_timing.html#a-solution" class="router-link-active router-link-exact-active sidebar-item" aria-label="A solution?"><!--[--><!--]--> A solution? <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/guides/lyc_timing.html#possible-fixes" class="router-link-active router-link-exact-active sidebar-item" aria-label="Possible fixes"><!--[--><!--]--> Possible fixes <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/guides/lyc_timing.html#but-wait" class="router-link-active router-link-exact-active sidebar-item" aria-label="But Wait!"><!--[--><!--]--> But Wait! <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/guides/lyc_timing.html#pros-and-cons" class="router-link-active router-link-exact-active sidebar-item" aria-label="Pros and Cons"><!--[--><!--]--> Pros and Cons <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/guides/lyc_timing.html#double-busy-loop" class="router-link-active router-link-exact-active sidebar-item" aria-label="Double-Busy-Loop"><!--[--><!--]--> Double-Busy-Loop <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/guides/lyc_timing.html#cycle-counting" class="router-link-active router-link-exact-active sidebar-item" aria-label="Cycle-counting"><!--[--><!--]--> Cycle-counting <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/guides/lyc_timing.html#combining-approaches" class="router-link-active router-link-exact-active sidebar-item" aria-label="Combining Approaches"><!--[--><!--]--> Combining Approaches <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/guides/lyc_timing.html#hybrid-cycle-counting" class="router-link-active router-link-exact-active sidebar-item" aria-label="Hybrid cycle-counting"><!--[--><!--]--> Hybrid cycle-counting <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="the-timing-of-lyc-stat-handlers" tabindex="-1"><a class="header-anchor" href="#the-timing-of-lyc-stat-handlers" aria-hidden="true">#</a> The Timing of LYC STAT Handlers</h1><p>Written by <a href="https://github.com/rondnelson99/" target="_blank" rel="noopener noreferrer">Ron Nelson<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> and <a href="https://eldred.fr" target="_blank" rel="noopener noreferrer">ISSOtm<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a></p><hr><p>Raster effects are probably the greatest assets that retro game consoles have. The fact that the PPU generates the image right as it is displayed allows many special effects to be created by modifying the rendering parameters while the image is being drawn. Here is an example:</p><figure><p><img src="/deadcscroll/gif/xysine.gif" alt="Example of raster effect"></p></figure><p>However, unlike some consoles like the SNES, the Game Boy contains no hardware dedicated to raster effects, so the task falls squarely on the CPU. This causes raster FX code to interact with the rest of the program in complex ways, particularly when it comes to <a href="https://gbdev.io/pandocs/Accessing_VRAM_and_OAM" target="_blank" rel="noopener noreferrer">accessing VRAM<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>.</p><p>In this article, we will explore different techniques for handling raster effects, and discuss their pros and cons with the help of some diagrams.</p><div class="custom-container warning"><p class="custom-container-title">PRIOR KNOWLEDGE ASSUMED</p><p>This article is not a friendly introduction to programming raster effects, and assumes you are already comfortable with Game Boy programming. To learn more about how to achieve neat raster effects like the above, check out <a href="/guides/deadcscroll.html" class="">DeadCScroll</a> first, which the above GIF is actually from!</p><p>Additionally, since the operations discussed here are <em>extremely</em> timing-sensitive, discussions will revolve around assembly instructions. You can learn how to program for the Game Boy in assembly in <a href="https://eldred.fr/gb-asm-tutorial" target="_blank" rel="noopener noreferrer">GB ASM Tutorial<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>.</p></div><div class="custom-container tip"><p class="custom-container-title">TERMINOLOGY</p><p>We&#39;ll reference a few terms throughout this tutorial; here are brief explanations of them:</p><ul><li><strong>SoC</strong>: <a href="https://en.wikipedia.org/wiki/System_on_a_chip" target="_blank" rel="noopener noreferrer">System-on-a-Chip<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>, a single chip that includes most (or all!) components of a system. The Game Boy&#39;s functionality is almost entirely contained within a single chip, confusingly labelled &quot;DMG-CPU&quot; or similar. (Contrast this with, for example, the SNES, where there is one chip for the CPU, two for the PPU, and many more.)</li><li><strong>CPU</strong>: Central Processing Unit, the part of the SoC that executes code and configures everything else.</li><li><strong>PPU</strong>: Pixel Processing Unit, the part of the SoC that is responsible for sending pixels to the LCD and generating them.</li><li><strong>Rasterization</strong>: the process of turning... something (for example, a collection of textured polygons; or, on the GB, tiles and tilemaps) into an array of pixels. &quot;Raster&quot; is sort of a contraction of that term.</li><li><strong>Scanline</strong>: a row of pixels; it&#39;s called a &quot;scan&quot;-line because the lines get drawn one by one, pixel by pixel, as if the PPU was &quot;scanning&quot; along the screen.</li><li><strong>Register</strong>: in general, a small piece of memory, usually linked to some hardware component.</li><li><strong>PPU mode</strong>: The PPU can be in one of four modes at a given time, depending on what it&#39;s doing. <a href="https://gbdev.io/pandocs/STAT" target="_blank" rel="noopener noreferrer">Please refer to Pan Docs<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> to learn what each mode corresponds to and how they are scheduled—they interact very tightly with raster effects.</li><li><strong>Interrupt</strong>: an event that gets generated. Typically, this causes a &quot;handler&quot; to be <code>call</code>ed, which is a special routine dedicated to reacting to a given interrupt.</li><li><strong>&quot;Main thread&quot;</strong>: any code that is executed outside of interrupt handlers.</li></ul></div><h2 id="introduction" tabindex="-1"><a class="header-anchor" href="#introduction" aria-hidden="true">#</a> Introduction</h2><p>The easiest way to implement raster effects is to use the <code>LYC</code> register with the STAT interrupt.</p><p>Here is what the Pan Docs have to say about this register&#39;s simple function:</p><blockquote><p><a href="https://gbdev.io/pandocs/Scrolling#ff45---lyc-ly-compare-rw" target="_blank" rel="noopener noreferrer"><strong>FF45 - LYC (LY Compare) (R/W)</strong><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a></p><p>The Game Boy permanently compares the value of the LYC and LY registers. When both values are identical, the “LYC=LY” flag in the STAT register is set, and (if enabled) a STAT interrupt is requested.</p></blockquote><p>So then, the outline for setting up a raster effect is as follows:</p><ol><li>Register an interrupt by setting <code>LYC</code> to the desired scanline</li><li>When that scanline begins, the STAT interrupt handler will automatically be called</li><li>Perform your chosen effect by modifying PPU registers</li><li>Exit the handler with <code>reti</code></li></ol><div class="custom-container tip"><p class="custom-container-title">ALTERNATIVES</p><p>There are other ways to perform raster FX, such as busy-waiting in the &quot;main thread&quot;, but as this article&#39;s title suggests, we won&#39;t discuss them here.</p><p>A major pro of <code>LYC</code>-interrupt-based raster effects is that they can be made self-contained, and thus largely independent of whatever the &quot;main thread&quot; is doing. This, in turn, simplifies the mental complexity of the code (decoupling), copes better with lag frames, and more.</p><p>Many of the points brought forth later, particularly regarding cycle counting, are still relevant with these alternatives, so this is still worth reading!</p></div><p>These four steps sound simple enough on their own, but there are numerous caveats we will discuss. Strap in!</p><ul><li>Most raster effects are implemented by modifying registers <em>between</em> scanlines. Thus, you will want to write the register either during Mode 2 (of the same scanline), or Mode 0 (of the previous one)—anything but Mode 3, really.<br> Unfortunately, <code>LY=LYC</code> interrupts are requested at the beginning of a scanline, so during the very short Mode 2, leaving too little time to perform but the most basic of effects.</li><li>Writing to the register during HBlank instead implies triggering the interrupt on the scanline <em>above</em> the effect, as well as idling for most of the scanline. So, if I wanted to enable sprites on scanline 16, I&#39;d write 15 to <code>LYC</code>.</li><li>Mode 3&#39;s length is variable, so syncing to HBlank is difficult and time-consuming.</li><li>The interrupt handler&#39;s execution may be delayed by a few cycles, which makes it difficult to reliably sync to the PPU.</li><li>If the &quot;main thread&quot; is itself trying to sync with the PPU (typically by polling <code>STAT</code> in a loop), our interrupt may throw off its timing.</li></ul><p>Sounds good? Then let&#39;s get started!</p><h2 id="timing" tabindex="-1"><a class="header-anchor" href="#timing" aria-hidden="true">#</a> Timing</h2><p>First, let&#39;s look at the timing of the rendering itself, <a href="https://gbdev.io/pandocs/pixel_fifo" target="_blank" rel="noopener noreferrer">courtesy of the Pan Docs<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>:</p><!----><p>Here are some key points:</p><ul><li>A &quot;dot&quot; is one period of the PPU&#39;s 4 MiHz clock, i.e. 0.25 µs.</li><li>A &quot;cycle&quot; is the main unit of time in the CPU, which is equal to 1 µs, or 4 dots. (The Game Boy Color CPU can enter a &quot;double-speed&quot; mode which halves the length of cycles, but not of dots. For the sake of simplicity, we won&#39;t consider the differences it involves here.)</li><li>Each scanline takes exactly 456 dots, or 114 cycles.</li><li>Mode 2 also takes a constant amount of time (20 cycles)</li><li>HBlank&#39;s length varies wildly, and will often be nearly as long as or longer than the drawing phase.</li><li>HBlank and OAM scan are mostly interchangeable, and long as you&#39;re not writing to OAM.</li><li>The worst-case HBlank&#39;s length is not a multiple of 4 dots, so we will round down to 21 cycles.</li></ul><p>Let&#39;s consider a simple STAT handler, which disables OBJs if called at line 128, and enables them otherwise:</p><div class="language-asm ext-asm line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#88C0D0;">LYC</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;">:</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">push</span><span style="color:#D8DEE9FF;"> af</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rLY]</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    cp </span><span style="color:#B48EAD;">128</span><span style="color:#D8DEE9FF;"> - </span><span style="color:#B48EAD;">1</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    jr z, .disableSprites</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#616E88;">; enable sprites</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rLCDC]</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">or</span><span style="color:#D8DEE9FF;"> a, LCDCF_OBJON</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh [rLCDC], a</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">pop</span><span style="color:#D8DEE9FF;"> af</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    reti</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">.disableSprites</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rLCDC]</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">and</span><span style="color:#D8DEE9FF;"> a, ~LCDCF_OBJON</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh [rLCDC], a</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">pop</span><span style="color:#D8DEE9FF;"> af</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    reti</span></span>
<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>This is not an especially well-written <code>STAT</code> handler, but the actual is outside the scope of this tutorial. If that&#39;s what you&#39;re looking for, check out <a href="deadcscroll">DeadCScroll</a> by Blitter Object. It triggers the STAT interrupt on HBlanks rather than <code>LYC</code>, but the fundamentals are the same.</p><p>Note that, for simplicity&#39;s sake, DeadCScroll does not consider the problems described further below, so be wary of combining that tutorial&#39;s STAT handler unmodified with <code>STAT</code>-based VRAM accesses in the main thread.</p></div><p>Let&#39;s assume that the interrupt fires at, say, scanline 42. Equipped with <a href="https://gbdev.io/gb-opcodes/optables" target="_blank" rel="noopener noreferrer">the GB instruction table<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> (see its legend at the bottom), we can plot how many cycles each operation takes, in relation with the PPU&#39;s mode:</p><figure class="timeline-figure"><div class="timeline-legend"><h3>Legend</h3><table><tr><th colspan="2">PPU Mode</th></tr><tr><td class="ppu-mode2">2</td><td>OAM scan</td></tr><tr><td class="ppu-mode3">3</td><td>Drawing</td></tr><tr><td class="ppu-mode0">0</td><td>HBlank</td></tr></table><table><tr><th colspan="2">CPU operation</th></tr><tr><td class="cpu-interrupt"></td><td>Interrupt dispatch</td></tr><tr><td class="cpu-op cpu-io"></td><td>Write to LCDC</td></tr><tr><td class="cpu-reti"></td><td>Return from interrupt</td></tr></table></div><table><thead><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></thead><tfoot><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></tfoot><tbody class="timeline"><tr><td class="ppu-mode2">0</td><td rowspan="5" class="cpu-interrupt" condensed="false"></td></tr><tr><td class="ppu-mode2">1</td></tr><tr><td class="ppu-mode2">2</td></tr><tr><td class="ppu-mode2">3</td></tr><tr><td class="ppu-mode2">4</td></tr><tr><td class="ppu-mode2">5</td><td rowspan="4" class="cpu-op" condensed="false"><code>push af</code></td></tr><tr><td class="ppu-mode2">6</td></tr><tr><td class="ppu-mode2">7</td></tr><tr><td class="ppu-mode2">8</td></tr><tr><td class="ppu-mode2">9</td><td rowspan="3" class="cpu-op" condensed="false"><code>ldh a, [rLY]</code></td></tr><tr><td class="ppu-mode2">10</td></tr><tr><td class="ppu-mode2">11</td></tr><tr><td class="ppu-mode2">12</td><td rowspan="2" class="cpu-op" condensed="false"><code>cp 128 - 1</code></td></tr><tr><td class="ppu-mode2">13</td></tr><tr><td class="ppu-mode2">14</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr z, .disableSprites</code></td></tr><tr><td class="ppu-mode2">15</td></tr><tr><td class="ppu-mode2">16</td><td rowspan="3" class="cpu-op" condensed="false"><code>ldh a, [rLCDC]</code></td></tr><tr><td class="ppu-mode2">17</td></tr><tr><td class="ppu-mode2">18</td></tr><tr><td class="ppu-mode2">19</td><td rowspan="2" class="cpu-op" condensed="false"><code>or a, LCDCF_OBJON</code></td></tr><tr><td class="ppu-mode3">20</td></tr><tr><td class="ppu-mode3">21</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>ldh [rLCDC], a</code></td></tr><tr><td class="ppu-mode3">22</td></tr><tr><td class="ppu-mode3">23</td></tr><tr><td class="ppu-mode3">24</td><td rowspan="3" class="cpu-op" condensed="false"><code>pop af</code></td></tr><tr><td class="ppu-mode3">25</td></tr><tr><td class="ppu-mode3">26</td></tr><tr><td class="ppu-mode3">27</td><td rowspan="4" class="cpu-reti" condensed="false"><code>reti</code></td></tr><tr><td class="ppu-mode3">28</td></tr><tr><td class="ppu-mode3">29</td></tr><tr><td class="ppu-mode3">30</td></tr></tbody></table></figure><p>The first 5 cycles do not have an instruction: indeed, calling an interrupt handler is not instantaneous, and the CPU is temporarily busy pushing the program counter (<code>PC</code>) to the stack, disabling interrupts, etc. Then, the actual interrupt handler begins execution.</p><p>We can immediately spot a problem: the cycle during which <code>LCDC</code> is written to falls in the middle of rendering! (With only a handful of exceptions, instructions that access memory do so on their very last cycle.) This is usually undesirable, and could lead to graphical glitches like an OBJ being partially cut off until we write to <code>LCDC</code>.</p><p>Another problem, less obvious but oh so painful, is how the interrupt handler might interact with the &quot;main thread&quot;&#39;s operation.</p><h3 id="the-vram-access-race-condition" tabindex="-1"><a class="header-anchor" href="#the-vram-access-race-condition" aria-hidden="true">#</a> The VRAM access <a href="https://en.wikipedia.org/wiki/Race_condition" target="_blank" rel="noopener noreferrer">race condition<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a></h3><p>Accessing VRAM <a href="https://gbdev.io/pandocs/Accessing_VRAM_and_OAM" target="_blank" rel="noopener noreferrer">is not possible during Mode 3<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>. Thus, when we want to access VRAM, precautions must be taken; the most common is to use the following loop:</p><div class="language-asm ext-asm line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#D8DEE9FF;">.waitVRAM</span></span>
<span class="line"><span style="color:#D8DEE9FF;">	ldh a, [rSTAT]</span></span>
<span class="line"><span style="color:#D8DEE9FF;">	</span><span style="color:#81A1C1;">and</span><span style="color:#D8DEE9FF;"> STATF_BUSY </span><span style="color:#616E88;">; 2</span></span>
<span class="line"><span style="color:#D8DEE9FF;">	jr nz, .waitVRAM</span></span>
<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>This loop checks whether <code>[STAT] &amp; 2</code> is zero, and exits when it does. Looking at <a href="https://gbdev.io/pandocs/STAT#ff41---stat-lcd-status-rw" target="_blank" rel="noopener noreferrer">documentation for <code>STAT</code><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>, we can see that the lowest 2 bits report the PPU&#39;s mode, and that <code>[STAT] &amp; 2</code> is zero for Mode 0 and Mode 1, but not Mode 2 or Mode 3. So, essentially, this loop waits for Mode 0 or Mode 1, which are both safe to write to VRAM—but it can&#39;t be that simple.</p><figure class="timeline-figure"><div class="timeline-legend"><h3>Legend</h3><table><tr><th colspan="2">PPU Mode</th></tr><tr><td class="ppu-mode2">2</td><td>OAM scan</td></tr><tr><td class="ppu-mode3">3</td><td>Drawing</td></tr><tr><td class="ppu-mode0">0</td><td>HBlank</td></tr></table><table><tr><th colspan="2">CPU operation</th></tr><tr><td class="cpu-op cpu-io"></td><td>Read from STAT</td></tr><tr><td class="cpu-critical"></td><td>VRAM accesses</td></tr></table></div><table><thead><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></thead><tfoot><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></tfoot><tbody class="timeline"><tr><td class="ppu-mode0">111</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>ldh a, [rSTAT]</code></td></tr><tr><td class="ppu-mode0">112</td></tr><tr><td class="ppu-mode0">113</td></tr><tr><td class="ppu-mode2">0</td><td rowspan="2" class="cpu-op" condensed="false"><code>and STATF_BUSY</code></td></tr><tr><td class="ppu-mode2">1</td></tr><tr><td class="ppu-mode2">2</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr nz, .waitVRAM</code></td></tr><tr><td class="ppu-mode2">3</td></tr><tr><td class="ppu-mode2">4</td><td rowspan="16" class="cpu-critical" condensed="false"></td></tr><tr><td class="ppu-mode2">5</td></tr><tr><td class="ppu-mode2">6</td></tr><tr><td class="ppu-mode2">7</td></tr><tr><td class="ppu-mode2">8</td></tr><tr><td class="ppu-mode2">9</td></tr><tr><td class="ppu-mode2">10</td></tr><tr><td class="ppu-mode2">11</td></tr><tr><td class="ppu-mode2">12</td></tr><tr><td class="ppu-mode2">13</td></tr><tr><td class="ppu-mode2">14</td></tr><tr><td class="ppu-mode2">15</td></tr><tr><td class="ppu-mode2">16</td></tr><tr><td class="ppu-mode2">17</td></tr><tr><td class="ppu-mode2">18</td></tr><tr><td class="ppu-mode2">19</td></tr><tr><td class="ppu-mode3">20</td><td rowspan="2" class="cpu-op" condensed="true"><b>(...)</b></td></tr><tr><td class="ppu-mode3">21</td></tr></tbody></table></figure><p>Pictured above is the &quot;worst case&quot; for this loop. As you can see, on the cycle that <code>STAT</code> is read, the PPU is still in Mode 0; however, checking for it takes a few cycles, during which we enter Mode 2!</p><p>Now, thankfully, Mode 2 is <em>also</em> safe for accessing VRAM—but only 16 cycles of it remain. This is why this loop is said to guarantee 16 &quot;VRAM-safe&quot; cycles: any access performed 17 cycles or more after it would break in this worst case.</p><p>Now, what would happen if our interrupt was requested in the middle of this?</p><figure class="timeline-figure"><div class="timeline-legend"><h3>Legend</h3><table><tr><th colspan="2">PPU Mode</th></tr><tr><td class="ppu-mode2">2</td><td>OAM scan</td></tr><tr><td class="ppu-mode3">3</td><td>Drawing</td></tr><tr><td class="ppu-mode0">0</td><td>HBlank</td></tr></table><table><tr><th colspan="2">CPU operation</th></tr><tr><td class="cpu-op cpu-io"></td><td>Read from STAT</td></tr><tr><td class="cpu-interrupt"></td><td>Interrupt dispatch</td></tr><tr><td class="cpu-reti"></td><td>Return from interrupt</td></tr><tr><td class="cpu-critical"></td><td>VRAM accesses</td></tr></table></div><table><thead><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></thead><tfoot><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></tfoot><tbody class="timeline"><tr><td class="ppu-mode0">111</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>ldh a, [rSTAT]</code></td></tr><tr><td class="ppu-mode0">112</td></tr><tr><td class="ppu-mode0">113</td></tr><tr><td class="ppu-mode2">0</td><td rowspan="5" class="cpu-interrupt" condensed="false"></td></tr><tr><td class="ppu-mode2">1</td></tr><tr><td class="ppu-mode2">2</td></tr><tr><td class="ppu-mode2">3</td></tr><tr><td class="ppu-mode2">4</td></tr><tr><td class="ppu-mode2">5</td><td rowspan="4" class="cpu-op" condensed="false"><code>push af</code></td></tr><tr><td class="ppu-mode2">6</td></tr><tr><td class="ppu-mode2">7</td></tr><tr><td class="ppu-mode2">8</td></tr><tr><td class="ppu-mode2">9</td><td rowspan="3" class="cpu-op" condensed="false"><code>ldh a, [rLY]</code></td></tr><tr><td class="ppu-mode2">10</td></tr><tr><td class="ppu-mode2">11</td></tr><tr><td class="ppu-mode2">12</td><td rowspan="2" class="cpu-op" condensed="false"><code>cp 128 - 1</code></td></tr><tr><td class="ppu-mode2">13</td></tr><tr><td class="ppu-mode2">14</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr z, .disableSprites</code></td></tr><tr><td class="ppu-mode2">15</td></tr><tr><td class="ppu-mode2">16</td><td rowspan="3" class="cpu-op" condensed="false"><code>ldh a, [rLCDC]</code></td></tr><tr><td class="ppu-mode2">17</td></tr><tr><td class="ppu-mode2">18</td></tr><tr><td class="ppu-mode2">19</td><td rowspan="2" class="cpu-op" condensed="false"><code>or a, LCDCF_OBJON</code></td></tr><tr><td class="ppu-mode3">20</td></tr><tr><td class="ppu-mode3">21</td><td rowspan="3" class="cpu-op" condensed="false"><code>ldh [rLCDC], a</code></td></tr><tr><td class="ppu-mode3">22</td></tr><tr><td class="ppu-mode3">23</td></tr><tr><td class="ppu-mode3">24</td><td rowspan="3" class="cpu-op" condensed="false"><code>pop af</code></td></tr><tr><td class="ppu-mode3">25</td></tr><tr><td class="ppu-mode3">26</td></tr><tr><td class="ppu-mode3">27</td><td rowspan="4" class="cpu-reti" condensed="false"><code>reti</code></td></tr><tr><td class="ppu-mode3">28</td></tr><tr><td class="ppu-mode3">29</td></tr><tr><td class="ppu-mode3">30</td></tr><tr><td class="ppu-mode3">31</td><td rowspan="2" class="cpu-op" condensed="false"><code>and STATF_BUSY</code></td></tr><tr><td class="ppu-mode3">32</td></tr><tr><td class="ppu-mode3">33</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr nz, .waitVRAM</code></td></tr><tr><td class="ppu-mode3">34</td></tr><tr><td class="ppu-mode3">35</td><td rowspan="16" class="cpu-critical" condensed="false"></td></tr><tr><td class="ppu-mode3">36</td></tr><tr><td class="ppu-mode3">37</td></tr><tr><td class="ppu-mode3">38</td></tr><tr><td class="ppu-mode3">39</td></tr><tr><td class="ppu-mode3">40</td></tr><tr><td class="ppu-mode3">41</td></tr><tr><td class="ppu-mode3">42</td></tr><tr><td class="ppu-mode3">43</td></tr><tr><td class="ppu-mode3">44</td></tr><tr><td class="ppu-mode3">45</td></tr><tr><td class="ppu-mode3">46</td></tr><tr><td class="ppu-mode3">47</td></tr><tr><td class="ppu-mode3">48</td></tr><tr><td class="ppu-mode3">49</td></tr><tr><td class="ppu-mode3">50</td></tr></tbody></table></figure><p>Oh no! The main thread is now trying to access VRAM right in the middle of Mode 3! This could lead to all sorts of visual bugs.</p><h3 id="a-solution" tabindex="-1"><a class="header-anchor" href="#a-solution" aria-hidden="true">#</a> A solution?</h3><p>The solution is not too complicated, at least on paper. We should be able to use the same <code>STAT</code>-checking loop (or at least, a variation of it) inside of the handler. It works in the main thread, so it should work here as well, right?</p><p>Remember that many <code>STAT</code> handlers will be much more complicated than the simple example above, so let&#39;s draw a diagram with an imaginary handler that would take significantly more time:</p><figure class="timeline-figure"><div class="timeline-legend"><h3>Legend</h3><table><tr><th colspan="2">PPU Mode</th></tr><tr><td class="ppu-mode2">2</td><td>OAM scan</td></tr><tr><td class="ppu-mode3">3</td><td>Drawing</td></tr><tr><td class="ppu-mode0">0</td><td>HBlank</td></tr></table><table><tr><th colspan="2">CPU operation</th></tr><tr><td class="cpu-op cpu-io"></td><td>Read from STAT</td></tr><tr><td class="cpu-interrupt"></td><td>Interrupt dispatch</td></tr><tr><td class="cpu-reti"></td><td>Return from interrupt</td></tr><tr><td class="cpu-critical"></td><td>VRAM accesses</td></tr></table></div><table><thead><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></thead><tfoot><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></tfoot><tbody class="timeline"><tr><td class="ppu-mode0">111</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>ldh a, [rSTAT]</code></td></tr><tr><td class="ppu-mode0">112</td></tr><tr><td class="ppu-mode0">113</td></tr><tr><td class="ppu-mode2">0</td><td rowspan="5" class="cpu-interrupt" condensed="false"></td></tr><tr><td class="ppu-mode2">1</td></tr><tr><td class="ppu-mode2">2</td></tr><tr><td class="ppu-mode2">3</td></tr><tr><td class="ppu-mode2">4</td></tr><tr><td class="ppu-mode2">5</td><td rowspan="3" class="cpu-op" condensed="true"><b>(...)</b></td></tr><tr><td style="background-image:linear-gradient(var(--ppu-mode2) 16%, var(--ppu-mode3) 16%, var(--ppu-mode3) 97%, var(--ppu-mode0) 97%);"><b>...</b></td></tr><tr><td class="ppu-mode0">96</td></tr><tr><td class="ppu-mode0">97</td><td rowspan="3" class="cpu-op" condensed="false"><code>ldh a, [rSTAT]</code></td></tr><tr><td class="ppu-mode0">98</td></tr><tr><td class="ppu-mode0">99</td></tr><tr><td class="ppu-mode0">100</td><td rowspan="2" class="cpu-op" condensed="false"><code>and STATF_BUSY</code></td></tr><tr><td class="ppu-mode0">101</td></tr><tr><td class="ppu-mode0">102</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr nz, .handlerWait</code></td></tr><tr><td class="ppu-mode0">103</td></tr><tr><td class="ppu-mode0">104</td><td rowspan="3" class="cpu-op" condensed="false"><code>(Write to LCDC)</code></td></tr><tr><td class="ppu-mode0">105</td></tr><tr><td class="ppu-mode0">106</td></tr><tr><td class="ppu-mode0">107</td><td rowspan="3" class="cpu-op" condensed="false"><code>pop hl</code></td></tr><tr><td class="ppu-mode0">108</td></tr><tr><td class="ppu-mode0">109</td></tr><tr><td class="ppu-mode0">110</td><td rowspan="3" class="cpu-op" condensed="false"><code>pop af</code></td></tr><tr><td class="ppu-mode0">111</td></tr><tr><td class="ppu-mode0">112</td></tr><tr><td class="ppu-mode0">113</td><td rowspan="4" class="cpu-reti" condensed="false"><code>reti</code></td></tr><tr><td class="ppu-mode2">0</td></tr><tr><td class="ppu-mode2">1</td></tr><tr><td class="ppu-mode2">2</td></tr><tr><td class="ppu-mode2">3</td><td rowspan="2" class="cpu-op" condensed="false"><code>and STATF_BUSY</code></td></tr><tr><td class="ppu-mode2">4</td></tr><tr><td class="ppu-mode2">5</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr nz, .waitVRAM</code></td></tr><tr><td class="ppu-mode2">6</td></tr><tr><td class="ppu-mode2">7</td><td rowspan="16" class="cpu-critical" condensed="false"></td></tr><tr><td class="ppu-mode2">8</td></tr><tr><td class="ppu-mode2">9</td></tr><tr><td class="ppu-mode2">10</td></tr><tr><td class="ppu-mode2">11</td></tr><tr><td class="ppu-mode2">12</td></tr><tr><td class="ppu-mode2">13</td></tr><tr><td class="ppu-mode2">14</td></tr><tr><td class="ppu-mode2">15</td></tr><tr><td class="ppu-mode2">16</td></tr><tr><td class="ppu-mode2">17</td></tr><tr><td class="ppu-mode2">18</td></tr><tr><td class="ppu-mode2">19</td></tr><tr><td class="ppu-mode3">20</td></tr><tr><td class="ppu-mode3">21</td></tr><tr><td class="ppu-mode3">22</td></tr></tbody></table></figure><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>All the instructions between the &quot;Interrupt dispatch&quot; and &quot;Return from interrupt&quot; blocks are the interrupt handler, the rest is in the &quot;main thread&quot;.</p></div><p>The <code>STAT</code> loop does fix the register being written to during Mode 3; however, once again, the 16 cycles that &quot;main thread&quot; expects to be VRAM-safe overlap with Mode 3. The problem here is that the write, <code>pop</code> and <code>reti</code> all take some of those cycles, and the &quot;main thread&quot; is using the value it read from <code>STAT</code> during the previous scanline—but that value is now stale.</p><h3 id="possible-fixes" tabindex="-1"><a class="header-anchor" href="#possible-fixes" aria-hidden="true">#</a> Possible fixes</h3><p>Using what we have learned so far, we can boil down the problem to three factors:</p><ol><li>Our handler can trigger in the middle of this sequence of events</li><li>Our handler preserves the stale value read from <code>STAT</code> earlier</li><li>Our handler returns during a time where accessing VRAM is unsafe</li></ol><p>It would be enough to get rid of <em>any</em> of these, so let&#39;s enumerate our options.</p><h4 id="dealing-with-it" tabindex="-1"><a class="header-anchor" href="#dealing-with-it" aria-hidden="true">#</a> Dealing with it</h4><p>It&#39;s entirely possible to accept the loss of some of those cycles. This amounts to assuming less than the usual 16 cycles after such loops. For example, putting a <code>STAT</code>-polling loop just before the last <code>pop af</code> and <code>reti</code> would have these two eat up 7 cycles, so we are down to 9.</p><p>This will quickly become impractical, requiring syncing to the LCD much more often in the main thread.</p><h4 id="handler-timing" tabindex="-1"><a class="header-anchor" href="#handler-timing" aria-hidden="true">#</a> Handler timing</h4><p>A simple way to prevent those pesky handlers from throwing off our timing is to disable them, with the <code>di</code> instruction. Unfortunately, it can&#39;t quite be so simple, as using <code>di</code> for this brings its own share of problems.</p><p>The most important one is that disabling the handlers like this <em>delays</em> their execution! <code>STAT</code> handlers designed to write to hardware regs during HBlank may start doing so during rendering instead; timer interrupts won&#39;t trigger as regularly now; and so on.</p><p>Using <code>di</code> is valid in some cases, but typically not when <code>STAT</code> interrupts are involved, due to their fairly strict timing requirements.</p><p>An oddly common alternative is to perform all VRAM updates in VBlank handler. (The reason why it&#39;s common especially in early GB games is likely being a carry-over from the NES, where the lack of HBlanks essentially mandates such a setup anyway.) While this can work, such as for <em>Metroid II</em>, it requires significant complexity from having to keep deferring graphical updates.</p><h4 id="stale-stat-read" tabindex="-1"><a class="header-anchor" href="#stale-stat-read" aria-hidden="true">#</a> Stale <code>STAT</code> read</h4><p>There is not much that can be done about this one. The interrupt handler <em>must</em> preserve registers, and ...</p><p>TOCTTOU</p><h4 id="return-timing" tabindex="-1"><a class="header-anchor" href="#return-timing" aria-hidden="true">#</a> Return timing</h4><p>This is the solution that the rest of this article will explore, as we will see that it makes the least painful compromises out of most use cases.</p><p>So, the real solution is to fully exit before the end of HBlank. There are two ways to do this. One is to wait for the Drawing phase before waiting for HBlank. This effectively catches the very start of HBlank, leaving plenty of time to exit. Here&#39;s how the earlier example might look using this method:</p><div class="language-asm ext-asm line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#88C0D0;">LYC</span><span style="color:#ECEFF4;">:</span><span style="color:#D8DEE9FF;">:</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">push</span><span style="color:#D8DEE9FF;"> af</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">push</span><span style="color:#D8DEE9FF;"> hl</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rLY]</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    cp </span><span style="color:#B48EAD;">128</span><span style="color:#D8DEE9FF;"> - </span><span style="color:#B48EAD;">1</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    jr z, .disableSprites</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#616E88;">; enable sprites</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rLCDC]</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">or</span><span style="color:#D8DEE9FF;"> a, LCDCF_OBJON</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    jr .finish</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">.disableSprites</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rLCDC]</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">and</span><span style="color:#D8DEE9FF;"> a, ~LCDCF_OBJON</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">.finish</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ld hl, rSTAT</span></span>
<span class="line"><span style="color:#D8DEE9FF;">.waitNotBlank</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    bit STATB_BUSY, [hl]</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    jr z, .waitNotBlank</span></span>
<span class="line"><span style="color:#D8DEE9FF;">.waitBlank</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    bit STATB_BUSY, [hl]</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    jr nz, .waitBlank</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh [rLCDC], a</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">pop</span><span style="color:#D8DEE9FF;"> hl</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">pop</span><span style="color:#D8DEE9FF;"> af</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    reti</span></span>
<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>See how this method never interferes with VRAM accesses in the main thread, even with the worst possible timing and the shortest of HBlanks:</p><figure class="timeline-figure"><div class="timeline-legend"><h3>Legend</h3><table><tr><th colspan="2">PPU Mode</th></tr><tr><td class="ppu-mode2">2</td><td>OAM scan</td></tr><tr><td class="ppu-mode3">3</td><td>Drawing</td></tr><tr><td class="ppu-mode0">0</td><td>HBlank</td></tr></table><table><tr><th colspan="2">CPU operation</th></tr><tr><td class="cpu-interrupt"></td><td>Interrupt dispatch</td></tr><tr><td class="cpu-op cpu-io"></td><td>STAT is tested</td></tr><tr><td class="cpu-reti"></td><td>Return from interrupt</td></tr><tr><td class="cpu-critical"></td><td>VRAM accesses</td></tr></table></div><table><thead><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></thead><tfoot><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></tfoot><tbody class="timeline"><tr><td class="ppu-mode0">111</td><td rowspan="3" class="cpu-op" condensed="false"><code>ldh a, [rSTAT]</code></td></tr><tr><td class="ppu-mode0">112</td></tr><tr><td class="ppu-mode0">113</td></tr><tr><td class="ppu-mode2">0</td><td rowspan="5" class="cpu-interrupt" condensed="false"></td></tr><tr><td class="ppu-mode2">1</td></tr><tr><td class="ppu-mode2">2</td></tr><tr><td class="ppu-mode2">3</td></tr><tr><td class="ppu-mode2">4</td></tr><tr><td class="ppu-mode2">5</td><td rowspan="4" class="cpu-op" condensed="false"><code>push af</code></td></tr><tr><td class="ppu-mode2">6</td></tr><tr><td class="ppu-mode2">7</td></tr><tr><td class="ppu-mode2">8</td></tr><tr><td class="ppu-mode2">9</td><td rowspan="4" class="cpu-op" condensed="false"><code>push hl</code></td></tr><tr><td class="ppu-mode2">10</td></tr><tr><td class="ppu-mode2">11</td></tr><tr><td class="ppu-mode2">12</td></tr><tr><td class="ppu-mode2">13</td><td rowspan="3" class="cpu-op" condensed="false"><code>ldh a, [rLY]</code></td></tr><tr><td class="ppu-mode2">14</td></tr><tr><td class="ppu-mode2">15</td></tr><tr><td class="ppu-mode2">16</td><td rowspan="2" class="cpu-op" condensed="false"><code>cp 128 - 1</code></td></tr><tr><td class="ppu-mode2">17</td></tr><tr><td class="ppu-mode2">18</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr z, .disableSprites</code></td></tr><tr><td class="ppu-mode2">19</td></tr><tr><td class="ppu-mode3">20</td><td rowspan="3" class="cpu-op" condensed="false"><code>ldh a, [rLCDC]</code></td></tr><tr><td class="ppu-mode3">21</td></tr><tr><td class="ppu-mode3">22</td></tr><tr><td class="ppu-mode3">23</td><td rowspan="2" class="cpu-op" condensed="false"><code>or a, LCDCF_OBJON</code></td></tr><tr><td class="ppu-mode3">24</td></tr><tr><td class="ppu-mode3">25</td><td rowspan="3" class="cpu-op" condensed="false"><code>jr .finish</code></td></tr><tr><td class="ppu-mode3">26</td></tr><tr><td class="ppu-mode3">27</td></tr><tr><td class="ppu-mode3">28</td><td rowspan="3" class="cpu-op" condensed="false"><code>ld hl, rSTAT</code></td></tr><tr><td class="ppu-mode3">29</td></tr><tr><td class="ppu-mode3">30</td></tr><tr><td class="ppu-mode3">31</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>bit STATB_BUSY, [hl]</code></td></tr><tr><td class="ppu-mode3">32</td></tr><tr><td class="ppu-mode3">33</td></tr><tr><td class="ppu-mode3">34</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr z, .waitNotBlank</code></td></tr><tr><td class="ppu-mode3">35</td></tr><tr><td class="ppu-mode3">36</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>bit STATB_BUSY, [hl]</code></td></tr><tr><td class="ppu-mode3">37</td></tr><tr><td class="ppu-mode3">38</td></tr><tr><td class="ppu-mode3">39</td><td rowspan="3" class="cpu-op" condensed="false"><code>jr nz, .waitBlank</code></td></tr><tr><td class="ppu-mode3">40</td></tr><tr><td class="ppu-mode3">41</td></tr><tr><td class="ppu-mode3">42</td><td rowspan="3" class="cpu-op" condensed="true"><b>(...)</b></td></tr><tr><td style="background-color:var(--ppu-mode3);"><b>...</b></td></tr><tr><td class="ppu-mode3">83</td></tr><tr><td class="ppu-mode3">84</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>bit STATB_BUSY, [hl]</code></td></tr><tr><td class="ppu-mode3">85</td></tr><tr><td class="ppu-mode3">86</td></tr><tr><td class="ppu-mode3">87</td><td rowspan="3" class="cpu-op" condensed="false"><code>jr nz, .waitBlank</code></td></tr><tr><td class="ppu-mode3">88</td></tr><tr><td class="ppu-mode3">89</td></tr><tr><td class="ppu-mode3">90</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>bit STATB_BUSY, [hl]</code></td></tr><tr><td class="ppu-mode3">91</td></tr><tr><td class="ppu-mode3">92</td></tr><tr><td class="ppu-mode0">93</td><td rowspan="3" class="cpu-op" condensed="false"><code>jr nz, .waitBlank</code></td></tr><tr><td class="ppu-mode0">94</td></tr><tr><td class="ppu-mode0">95</td></tr><tr><td class="ppu-mode0">96</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>bit STATB_BUSY, [hl]</code></td></tr><tr><td class="ppu-mode0">97</td></tr><tr><td class="ppu-mode0">98</td></tr><tr><td class="ppu-mode0">99</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr nz, .waitBlank</code></td></tr><tr><td class="ppu-mode0">100</td></tr><tr><td class="ppu-mode0">101</td><td rowspan="3" class="cpu-op" condensed="false"><code>ldh [rLCDC], a</code></td></tr><tr><td class="ppu-mode0">102</td></tr><tr><td class="ppu-mode0">103</td></tr><tr><td class="ppu-mode0">104</td><td rowspan="3" class="cpu-op" condensed="false"><code>pop hl</code></td></tr><tr><td class="ppu-mode0">105</td></tr><tr><td class="ppu-mode0">106</td></tr><tr><td class="ppu-mode0">107</td><td rowspan="3" class="cpu-op" condensed="false"><code>pop af</code></td></tr><tr><td class="ppu-mode0">108</td></tr><tr><td class="ppu-mode0">109</td></tr><tr><td class="ppu-mode0">110</td><td rowspan="4" class="cpu-reti" condensed="false"><code>reti</code></td></tr><tr><td class="ppu-mode0">111</td></tr><tr><td class="ppu-mode0">112</td></tr><tr><td class="ppu-mode0">113</td></tr><tr><td class="ppu-mode2">0</td><td rowspan="2" class="cpu-op" condensed="false"><code>and STATF_BUSY</code></td></tr><tr><td class="ppu-mode2">1</td></tr><tr><td class="ppu-mode2">2</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr nz, .waitVRAM</code></td></tr><tr><td class="ppu-mode2">3</td></tr><tr><td class="ppu-mode2">4</td><td rowspan="3" class="cpu-critical" condensed="true"><b>(...)</b></td></tr><tr><td style="background-color:var(--ppu-mode2);"><b>...</b></td></tr><tr><td class="ppu-mode2">19</td></tr></tbody></table></figure><p>Phew! This just barely works. There are only two cycles to spare! If there were multiple registers that needed updating, you might run into trouble. Normally, These really short HBlanks are the worst-case scenario that you always fear. However, in practice, HBlanks are normally much longer, often even longer than the drawing phase. Using this method, that can actually have unfortunate consequences:</p><figure class="timeline-figure"><div class="timeline-legend"><h3>Legend</h3><table><tr><th colspan="2">PPU Mode</th></tr><tr><td class="ppu-mode2">2</td><td>OAM scan</td></tr><tr><td class="ppu-mode3">3</td><td>Drawing</td></tr><tr><td class="ppu-mode0">0</td><td>HBlank</td></tr></table><table><tr><th colspan="2">CPU operation</th></tr><tr><td class="cpu-interrupt"></td><td>Interrupt dispatch</td></tr><tr><td class="cpu-op cpu-io"></td><td>STAT is tested</td></tr><tr><td class="cpu-reti"></td><td>Return from interrupt</td></tr><tr><td class="cpu-critical"></td><td>VRAM accesses</td></tr></table></div><table><thead><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></thead><tfoot><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></tfoot><tbody class="timeline"><tr><td class="ppu-mode0">111</td><td rowspan="3" class="cpu-op" condensed="false"><code>ldh a, [rSTAT]</code></td></tr><tr><td class="ppu-mode0">112</td></tr><tr><td class="ppu-mode0">113</td></tr><tr><td class="ppu-mode2">0</td><td rowspan="5" class="cpu-interrupt" condensed="false"></td></tr><tr><td class="ppu-mode2">1</td></tr><tr><td class="ppu-mode2">2</td></tr><tr><td class="ppu-mode2">3</td></tr><tr><td class="ppu-mode2">4</td></tr><tr><td class="ppu-mode2">5</td><td rowspan="4" class="cpu-op" condensed="false"><code>push af</code></td></tr><tr><td class="ppu-mode2">6</td></tr><tr><td class="ppu-mode2">7</td></tr><tr><td class="ppu-mode2">8</td></tr><tr><td class="ppu-mode2">9</td><td rowspan="4" class="cpu-op" condensed="false"><code>push hl</code></td></tr><tr><td class="ppu-mode2">10</td></tr><tr><td class="ppu-mode2">11</td></tr><tr><td class="ppu-mode2">12</td></tr><tr><td class="ppu-mode2">13</td><td rowspan="3" class="cpu-op" condensed="true"><b>(...)</b></td></tr><tr><td style="background-image:linear-gradient(var(--ppu-mode2) 14%, var(--ppu-mode3) 14%);"><b>...</b></td></tr><tr><td class="ppu-mode3">58</td></tr><tr><td class="ppu-mode3">59</td><td rowspan="3" class="cpu-op" condensed="false"><code>ld hl, rSTAT</code></td></tr><tr><td class="ppu-mode3">60</td></tr><tr><td class="ppu-mode3">61</td></tr><tr><td class="ppu-mode3">62</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>bit STATB_BUSY, [hl]</code></td></tr><tr><td class="ppu-mode0">63</td></tr><tr><td class="ppu-mode0">64</td></tr><tr><td class="ppu-mode0">65</td><td rowspan="3" class="cpu-op" condensed="false"><code>jr z, .waitNotBlank</code></td></tr><tr><td class="ppu-mode0">66</td></tr><tr><td class="ppu-mode0">67</td></tr><tr><td class="ppu-mode0">68</td><td rowspan="3" class="cpu-op" condensed="true"><b>(...)</b></td></tr><tr><td style="background-image:linear-gradient(var(--ppu-mode0) 98%, var(--ppu-mode2) 98%);"><b>...</b></td></tr><tr><td class="ppu-mode2">1</td></tr><tr><td class="ppu-mode2">2</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>bit STATB_BUSY, [hl]</code></td></tr><tr><td class="ppu-mode2">3</td></tr><tr><td class="ppu-mode2">4</td></tr><tr><td class="ppu-mode2">5</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr z, .waitNotBlank</code></td></tr><tr><td class="ppu-mode2">6</td></tr><tr><td class="ppu-mode2">7</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>bit STATB_BUSY, [hl]</code></td></tr><tr><td class="ppu-mode2">8</td></tr><tr><td class="ppu-mode2">9</td></tr><tr><td class="ppu-mode2">10</td><td rowspan="3" class="cpu-op" condensed="false"><code>jr nz, .waitBlank</code></td></tr><tr><td class="ppu-mode2">11</td></tr><tr><td class="ppu-mode2">12</td></tr><tr><td class="ppu-mode2">13</td><td rowspan="3" class="cpu-op" condensed="true"><b>(...)</b></td></tr><tr><td style="background-image:linear-gradient(var(--ppu-mode2) 14%, var(--ppu-mode3) 14%);"><b>...</b></td></tr><tr><td class="ppu-mode3">60</td></tr><tr><td class="ppu-mode3">61</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>bit STATB_BUSY, [hl]</code></td></tr><tr><td class="ppu-mode3">62</td></tr><tr><td class="ppu-mode0">63</td></tr><tr><td class="ppu-mode0">64</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr nz, .waitBlank</code></td></tr><tr><td class="ppu-mode0">65</td></tr><tr><td class="ppu-mode0">66</td><td rowspan="3" class="cpu-op" condensed="false"><code>ldh [rLCDC], a</code></td></tr><tr><td class="ppu-mode0">67</td></tr><tr><td class="ppu-mode0">68</td></tr><tr><td class="ppu-mode0">69</td><td rowspan="3" class="cpu-op" condensed="false"><code>pop hl</code></td></tr><tr><td class="ppu-mode0">70</td></tr><tr><td class="ppu-mode0">71</td></tr><tr><td class="ppu-mode0">72</td><td rowspan="3" class="cpu-op" condensed="false"><code>pop af</code></td></tr><tr><td class="ppu-mode0">73</td></tr><tr><td class="ppu-mode0">74</td></tr><tr><td class="ppu-mode0">75</td><td rowspan="4" class="cpu-reti" condensed="false"><code>reti</code></td></tr><tr><td class="ppu-mode0">76</td></tr><tr><td class="ppu-mode0">77</td></tr><tr><td class="ppu-mode0">78</td></tr><tr><td class="ppu-mode0">79</td><td rowspan="2" class="cpu-op" condensed="false"><code>and STATF_BUSY</code></td></tr><tr><td class="ppu-mode0">80</td></tr><tr><td class="ppu-mode0">81</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr nz, .waitVRAM</code></td></tr><tr><td class="ppu-mode0">82</td></tr><tr><td class="ppu-mode0">83</td><td rowspan="3" class="cpu-critical" condensed="true"><b>(...)</b></td></tr><tr><td style="background-color:var(--ppu-mode0);"><b>...</b></td></tr><tr><td class="ppu-mode0">98</td></tr></tbody></table></figure><p>This time, when all the processing was done, there was still plenty of time left in the scanline to safely exit. However, since HBlank was so long, the routine missed the check for the drawing window and wasted an entire scanline waiting for that Drawing -&gt; HBlank transition before it exited. Not only does this waste precious CPU time, but it also limits how often raster FX can be used throughout the frame. This method still works fine though, and can be an easy approach if you use Raster FX sparingly.</p><p>I&#39;m a bit of a perfectionist, so I usually like to strive for the absolute best method. In a perfect world, we would precisely know whether we have enough HBlank left to safely exit. There actually is a way to do that though! You just need to count exactly how long your routine takes, and make sure it always exits during HBlank. This comes with some caveats though. Most routines, if they haven&#39;t been specifically designed for this method, will take a variable amount of time. The main things you need to avoid are <code>if</code> statements and loops. Specifically, if statements of this form are problematic:</p><div class="language-asm ext-asm line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#616E88;">; test a condition here...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">    jr nc, .skip </span><span style="color:#616E88;">; skip the next part unless Carry is set</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#616E88;">; do something here, only if the previous operation set Carry</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">.skip</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#616E88;">; continue on with the program.</span></span>
<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>The problem here is that the code following this pattern may be run after a variable number of cycles have passed. If you need to use an if statement, always make it an if/else statement so that you can waste cycles in the <code>else</code> portion and take the same number of cycles.</p><p>So now that you&#39;re ready to count the cycles of your handler, how long do you need to make the routine? Let&#39;s look at some more diagrams to figure this out!</p><figure class="timeline-figure"><div class="timeline-legend"><h3>Legend</h3><table><tr><th colspan="2">PPU Mode</th></tr><tr><td class="ppu-mode2">2</td><td>OAM scan</td></tr><tr><td class="ppu-mode3">3</td><td>Drawing</td></tr><tr><td class="ppu-mode0">0</td><td>HBlank</td></tr></table><table><tr><th colspan="2">CPU operation</th></tr><tr><td class="cpu-op cpu-io"></td><td>STAT read</td></tr><tr><td class="cpu-interrupt"></td><td>Interrupt dispatch</td></tr><tr><td class="cpu-reti"></td><td>Return from interrupt</td></tr><tr><td class="cpu-critical"></td><td>VRAM accesses</td></tr></table></div><table><thead><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></thead><tfoot><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></tfoot><tbody class="timeline"><tr><td class="ppu-mode0">111</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>ldh a, [rSTAT]</code></td></tr><tr><td class="ppu-mode0">112</td></tr><tr><td class="ppu-mode0">113</td></tr><tr><td class="ppu-mode2">0</td><td rowspan="5" class="cpu-interrupt" condensed="false"></td></tr><tr><td class="ppu-mode2">1</td></tr><tr><td class="ppu-mode2">2</td></tr><tr><td class="ppu-mode2">3</td></tr><tr><td class="ppu-mode2">4</td></tr><tr><td class="ppu-mode2">5</td><td rowspan="3" class="cpu-op" condensed="true"><b>(...)</b></td></tr><tr><td style="background-image:linear-gradient(var(--ppu-mode2) 14%, var(--ppu-mode3) 14%, var(--ppu-mode3) 85%, var(--ppu-mode0) 85%);"><b>...</b></td></tr><tr><td class="ppu-mode0">109</td></tr><tr><td class="ppu-mode0">110</td><td rowspan="4" class="cpu-reti" condensed="false"><code>reti</code></td></tr><tr><td class="ppu-mode0">111</td></tr><tr><td class="ppu-mode0">112</td></tr><tr><td class="ppu-mode0">113</td></tr><tr><td class="ppu-mode2">0</td><td rowspan="2" class="cpu-op" condensed="false"><code>and STATF_BUSY</code></td></tr><tr><td class="ppu-mode2">1</td></tr><tr><td class="ppu-mode2">2</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr nz, .waitVRAM</code></td></tr><tr><td class="ppu-mode2">3</td></tr><tr><td class="ppu-mode2">4</td><td rowspan="3" class="cpu-critical" condensed="true"><b>(...)</b></td></tr><tr><td style="background-color:var(--ppu-mode2);"><b>...</b></td></tr><tr><td class="ppu-mode2">19</td></tr></tbody></table></figure><p>Wow! That&#39;s a lot of cycles! Here, the routine takes exactly one scanline to complete, so the main thread does its writes at the same moment on the next scanline, with no idea what happened! If you count up all the cyan cycles, you&#39;ll see that there are 105 of them, and 109 if you count the <code>reti</code>. This extra time makes it possible to write to two or three registers safely, rather than just one. If you don&#39;t need all that time, you can make it shorter as well:</p><figure class="timeline-figure"><div class="timeline-legend"><h3>Legend</h3><table><tr><th colspan="2">PPU Mode</th></tr><tr><td class="ppu-mode2">2</td><td>OAM scan</td></tr><tr><td class="ppu-mode3">3</td><td>Drawing</td></tr><tr><td class="ppu-mode0">0</td><td>HBlank</td></tr></table><table><tr><th colspan="2">CPU operation</th></tr><tr><td class="cpu-op cpu-io"></td><td>STAT read</td></tr><tr><td class="cpu-interrupt"></td><td>Interrupt dispatch</td></tr><tr><td class="cpu-reti"></td><td>Return from interrupt</td></tr><tr><td class="cpu-critical"></td><td>VRAM accesses</td></tr></table></div><table><thead><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></thead><tfoot><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></tfoot><tbody class="timeline"><tr><td class="ppu-mode0">107</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>ldh a, [rSTAT]</code></td></tr><tr><td class="ppu-mode0">108</td></tr><tr><td class="ppu-mode0">109</td></tr><tr><td class="ppu-mode0">110</td><td rowspan="2" class="cpu-op" condensed="false"><code>and STATF_BUSY</code></td></tr><tr><td class="ppu-mode0">111</td></tr><tr><td class="ppu-mode0">112</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr nz, .waitVRAM</code></td></tr><tr><td class="ppu-mode0">113</td></tr><tr><td class="ppu-mode2">0</td><td rowspan="5" class="cpu-interrupt" condensed="false"></td></tr><tr><td class="ppu-mode2">1</td></tr><tr><td class="ppu-mode2">2</td></tr><tr><td class="ppu-mode2">3</td></tr><tr><td class="ppu-mode2">4</td></tr><tr><td class="ppu-mode2">5</td><td rowspan="3" class="cpu-op" condensed="true"><b>(...)</b></td></tr><tr><td style="background-image:linear-gradient(var(--ppu-mode2) 18%, var(--ppu-mode3) 18%);"><b>...</b></td></tr><tr><td class="ppu-mode3">88</td></tr><tr><td class="ppu-mode3">89</td><td rowspan="4" class="cpu-reti" condensed="false"><code>reti</code></td></tr><tr><td class="ppu-mode3">90</td></tr><tr><td class="ppu-mode3">91</td></tr><tr><td class="ppu-mode3">92</td></tr><tr><td class="ppu-mode0">93</td><td rowspan="3" class="cpu-critical" condensed="true"><b>(...)</b></td></tr><tr><td style="background-color:var(--ppu-mode0);"><b>...</b></td></tr><tr><td class="ppu-mode0">108</td></tr></tbody></table></figure><p>This time, I put the <code>and</code> and <code>jr</code> before the interrupt, so that when it resumes, it&#39;s all ready to start writing to VRAM. This interrupt routine is 87 cycles long, including the <code>reti</code>. This won&#39;t often prove especially useful though, because you never take any time during HBlank to actually do any register writes. However, you could use this if your routine has a case where it realizes that nothing actually needs to be written, and you can exit earlier.</p><p>From those two diagrams, you&#39;ll see that the 22 cycles of worst-case HBlank is the time you can use to write to any PPU registers, pop your registers back, and then exit with <code>reti</code>. These 22 cycles are cycle 88 through cycle 109, inclusive.</p><p>What if I told you that you could actually have your handler take only 86 cycles? Well, you can!</p><figure class="timeline-figure"><div class="timeline-legend"><h3>Legend</h3><table><tr><th colspan="2">PPU Mode</th></tr><tr><td class="ppu-mode2">2</td><td>OAM scan</td></tr><tr><td class="ppu-mode3">3</td><td>Drawing</td></tr><tr><td class="ppu-mode0">0</td><td>HBlank</td></tr></table><table><tr><th colspan="2">CPU operation</th></tr><tr><td class="cpu-op cpu-io"></td><td>STAT read</td></tr><tr><td class="cpu-interrupt"></td><td>Interrupt dispatch</td></tr><tr><td class="cpu-reti"></td><td>Return from interrupt</td></tr><tr><td class="cpu-critical"></td><td>VRAM accesses</td></tr></table></div><table><thead><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></thead><tfoot><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></tfoot><tbody class="timeline"><tr><td class="ppu-mode0">107</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>ldh a, [rSTAT]</code></td></tr><tr><td class="ppu-mode0">108</td></tr><tr><td class="ppu-mode0">109</td></tr><tr><td class="ppu-mode0">110</td><td rowspan="2" class="cpu-op" condensed="false"><code>and STATF_BUSY</code></td></tr><tr><td class="ppu-mode0">111</td></tr><tr><td class="ppu-mode0">112</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr nz, .waitVRAM</code></td></tr><tr><td class="ppu-mode0">113</td></tr><tr><td class="ppu-mode2">0</td><td rowspan="5" class="cpu-interrupt" condensed="false"></td></tr><tr><td class="ppu-mode2">1</td></tr><tr><td class="ppu-mode2">2</td></tr><tr><td class="ppu-mode2">3</td></tr><tr><td class="ppu-mode2">4</td></tr><tr><td class="ppu-mode2">5</td><td rowspan="3" class="cpu-op" condensed="true"><b>(...)</b></td></tr><tr><td style="background-image:linear-gradient(var(--ppu-mode2) 18%, var(--ppu-mode3) 18%);"><b>...</b></td></tr><tr><td class="ppu-mode3">87</td></tr><tr><td class="ppu-mode3">88</td><td rowspan="4" class="cpu-reti" condensed="false"><code>reti</code></td></tr><tr><td class="ppu-mode3">89</td></tr><tr><td class="ppu-mode3">90</td></tr><tr><td class="ppu-mode3">91</td></tr><tr><td class="ppu-mode3">92</td><td rowspan="3" class="cpu-critical" condensed="true"><b>(...)</b></td></tr><tr><td style="background-color:var(--ppu-mode0);"><b>...</b></td></tr><tr><td class="ppu-mode0">107</td></tr></tbody></table></figure><p>This seems bad, since the first cycle of the red bar, where the main thread may try to access VRAM, is potentially during the Drawing phase! This is also fine though. All instructions that access memory, whether through an immediate address or using a register pair as a pointer, take multiple cycles to complete. That&#39;s because the first cycle of every instruction is used to fetch the operation code itself. The memory access that the instruction performs is always in the 2nd, 3rd or 4th cycle of the instruction. In this situation, the 2nd cycle of the VRAM-accessible time is in HBlank, so this won&#39;t actually cause any problems.</p><h2 id="but-wait" tabindex="-1"><a class="header-anchor" href="#but-wait" aria-hidden="true">#</a> But Wait!</h2><p>The interrupt latency I showed earlier doesn&#39;t actually tell the full story. Before it even starts to service the interrupt, the system waits for the current instruction to finish. This is how that might look with the longest allowable routine:</p><figure class="timeline-figure"><div class="timeline-legend"><h3>Legend</h3><table><tr><th colspan="2">PPU Mode</th></tr><tr><td class="ppu-mode2">2</td><td>OAM scan</td></tr><tr><td class="ppu-mode3">3</td><td>Drawing</td></tr><tr><td class="ppu-mode0">0</td><td>HBlank</td></tr></table><table><tr><th colspan="2">CPU operation</th></tr><tr><td class="cpu-op cpu-io"></td><td>STAT read</td></tr><tr><td class="cpu-interrupt"></td><td>Interrupt dispatch</td></tr><tr><td class="cpu-reti"></td><td>Return from interrupt</td></tr><tr><td class="cpu-critical"></td><td>VRAM accesses</td></tr></table></div><table><thead><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></thead><tfoot><tr><th>Scanline<br>cycle</th><th>Instruction</th></tr></tfoot><tbody class="timeline"><tr><td class="ppu-mode0">106</td><td rowspan="3" class="cpu-op cpu-io" condensed="false"><code>ldh a, [rSTAT]</code></td></tr><tr><td class="ppu-mode0">107</td></tr><tr><td class="ppu-mode0">108</td></tr><tr><td class="ppu-mode0">109</td><td rowspan="2" class="cpu-op" condensed="false"><code>and STATF_BUSY</code></td></tr><tr><td class="ppu-mode0">110</td></tr><tr><td class="ppu-mode0">111</td><td rowspan="2" class="cpu-op" condensed="false"><code>jr nz, .waitVRAM</code></td></tr><tr><td class="ppu-mode0">112</td></tr><tr><td class="ppu-mode0">113</td><td rowspan="6" class="cpu-call" condensed="false"><code>call SomeFunc</code></td></tr><tr><td class="ppu-mode2">0</td></tr><tr><td class="ppu-mode2">1</td></tr><tr><td class="ppu-mode2">2</td></tr><tr><td class="ppu-mode2">3</td></tr><tr><td class="ppu-mode2">4</td></tr><tr><td class="ppu-mode2">5</td><td rowspan="5" class="cpu-interrupt" condensed="false"></td></tr><tr><td class="ppu-mode2">6</td></tr><tr><td class="ppu-mode2">7</td></tr><tr><td class="ppu-mode2">8</td></tr><tr><td class="ppu-mode2">9</td></tr><tr><td class="ppu-mode2">10</td><td rowspan="3" class="cpu-op" condensed="true"><b>(...)</b></td></tr><tr><td style="background-image:linear-gradient(var(--ppu-mode2) 9%, var(--ppu-mode3) 9%, var(--ppu-mode3) 51%, var(--ppu-mode0) 51%);"><b>...</b></td></tr><tr><td class="ppu-mode2">0</td></tr><tr><td class="ppu-mode2">1</td><td rowspan="4" class="cpu-reti" condensed="false"><code>reti</code></td></tr><tr><td class="ppu-mode2">2</td></tr><tr><td class="ppu-mode2">3</td></tr><tr><td class="ppu-mode2">4</td></tr><tr><td class="ppu-mode2">5</td><td rowspan="3" class="cpu-critical" condensed="true"><b>(...)</b></td></tr><tr><td style="background-color:var(--ppu-mode2);"><b>...</b></td></tr><tr><td class="ppu-mode2">14</td></tr></tbody></table></figure><p>Here, the first green block shows the system waiting 5 cycles for a <code>call</code> instruction to finish. <code>call</code> is the longest instruction at 6 cycles, so if the interrupt is requested just after it begins, the system will wait 5 cycles for it to complete. This seems bad, since the routine exited after the end of HBlank. However, this is actually fine! Those waiting cycles were not wasted; they were still 5 cycles of work that the main thread got done. So in the end, the main thread still gets its 20 cycles of VRAM-accessible time.</p><h2 id="pros-and-cons" tabindex="-1"><a class="header-anchor" href="#pros-and-cons" aria-hidden="true">#</a> Pros and Cons</h2><p>Thus far, I have presented two very different methods for making safe <code>LYC</code> handlers, and each have their pros and cons.</p><h2 id="double-busy-loop" tabindex="-1"><a class="header-anchor" href="#double-busy-loop" aria-hidden="true">#</a> Double-Busy-Loop</h2><p><strong>Pros</strong></p><ul><li>does not require all code to be constant-time</li><li>does not require tedious cycle-counting</li><li>may exit very early if the routine finishes quickly</li></ul><p><strong>Cons</strong></p><ul><li>does not provide enough HBlank time to safely write multiple registers</li><li>if the routine takes too long, it may miss mode 3 and waste an entire scanline before exiting</li></ul><h2 id="cycle-counting" tabindex="-1"><a class="header-anchor" href="#cycle-counting" aria-hidden="true">#</a> Cycle-counting</h2><p><strong>Pros</strong></p><ul><li>leaves more time for more complex logic in the routine</li><li>allows enough time during blanking to write to up to three registers</li><li>never takes longer than one scanline</li></ul><p><strong>Cons</strong></p><ul><li>requires all code to be constant-time</li><li>requires tedious cycle-counting</li><li>always takes close to an entire scanline, even if HBlank starts much sooner</li></ul><p>This suggests that the double-busy-loop method is good for extremely simple <code>LYC</code> routines that only need to write to one register, or routines that for some reason cannot be cycle-counted. If you need more time for calculations and more time to write to those registers, you can cycle-count your routine.</p><p>But what if you could combine both these methods? Enter the <strong>Hybrid Cycle-Counted Handler™</strong>, a technique I came up with while writing this document.</p><h2 id="combining-approaches" tabindex="-1"><a class="header-anchor" href="#combining-approaches" aria-hidden="true">#</a> Combining Approaches</h2><p>The goal of this method is to combine the maximum HBlank time that cycle-counting delivers, while still exiting early when HBlank is longer. Here is an example. If you&#39;ve read <a href="deadcscroll">DeadCScroll</a>, you&#39;ll recognise this as that tutorial&#39;s <code>STAT</code> Handler, modified to start at Mode 2 rather than HBlank, and be safe towards VRAM accesses in the main thread.</p><div class="language-asm ext-asm line-numbers-mode"><pre class="shiki" style="background-color:#2e3440ff;"><code><span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">push</span><span style="color:#D8DEE9FF;"> af </span><span style="color:#616E88;">; 4</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">push</span><span style="color:#D8DEE9FF;"> hl </span><span style="color:#616E88;">; 8</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#616E88;">; obtain the pointer to the data pair</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rLY] </span><span style="color:#616E88;">; 11</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">inc</span><span style="color:#D8DEE9FF;"> a </span><span style="color:#616E88;">; 12</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">add</span><span style="color:#D8DEE9FF;"> a, a </span><span style="color:#616E88;">; 13 ; double the offset since each line uses 2 bytes</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ld l, a </span><span style="color:#616E88;">; 14</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh a, [hDrawBuffer] </span><span style="color:#616E88;">; 17</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">adc</span><span style="color:#D8DEE9FF;"> </span><span style="color:#B48EAD;">0</span><span style="color:#D8DEE9FF;"> </span><span style="color:#616E88;">; 19</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ld h, a </span><span style="color:#616E88;">; 20 ; hl now points to somewhere in the draw buffer</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">call</span><span style="color:#D8DEE9FF;"> UnconditionalRet </span><span style="color:#616E88;">; just waste 31 cycles while we wait for HBlank to maybe start</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">call</span><span style="color:#D8DEE9FF;"> UnconditionalRet</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">call</span><span style="color:#D8DEE9FF;"> UnconditionalRet</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">nop</span><span style="color:#D8DEE9FF;"> </span><span style="color:#616E88;">; 51</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#616E88;">; now start trying to look for HBlank to exit early</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rSTAT]</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">and</span><span style="color:#D8DEE9FF;"> STATF_BUSY</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    jr z, .setAndExit </span><span style="color:#616E88;">; 58</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rSTAT]</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">and</span><span style="color:#D8DEE9FF;"> STATF_BUSY</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    jr z, .setAndExit </span><span style="color:#616E88;">; 65</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rSTAT]</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">and</span><span style="color:#D8DEE9FF;"> STATF_BUSY</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    jr z, .setAndExit </span><span style="color:#616E88;">; 72</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh a, [rSTAT]</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">and</span><span style="color:#D8DEE9FF;"> STATF_BUSY</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    jr z, .setAndExit </span><span style="color:#616E88;">; 79</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">nop</span><span style="color:#D8DEE9FF;"> </span><span style="color:#616E88;">; waste 4 more cycles since there isn&#39;t time for another check</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">nop</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">nop</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">nop</span><span style="color:#D8DEE9FF;"> </span><span style="color:#616E88;">; 83</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">.setAndExit</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#616E88;">; set the scroll registers</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ld a,[hl+] </span><span style="color:#616E88;">; 85</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh [rSCY],a </span><span style="color:#616E88;">; 88</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ld a,[hl+] </span><span style="color:#616E88;">; 90</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    ldh [rSCX],a </span><span style="color:#616E88;">; 93</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">pop</span><span style="color:#D8DEE9FF;"> hl </span><span style="color:#616E88;">; 97</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    </span><span style="color:#81A1C1;">pop</span><span style="color:#D8DEE9FF;"> af </span><span style="color:#616E88;">; 100</span></span>
<span class="line"><span style="color:#D8DEE9FF;">    reti </span><span style="color:#616E88;">; 104</span></span>
<span class="line"></span></code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br></div></div><p>Once the handler finishes its logic, the handler delays cycles until it reaches the window then HBlank might start. With a 5-cycle offset due to a <code>call</code>, and the longest possible HBlank, the earliest HBlank might start is cycle 54, so that&#39;s the first attempt to read <code>STAT</code>. It keeps checking <code>STAT</code> until even in the worst-case scenario, it knows that HBlank will start. Then, it uses that time to write the scroll registers and exit. This way, it can still exit early, as long as the HBlank length permits. This routine takes 104 cycles in the worst-case scenario, but may take as few as 79 if HBlank comes sooner.</p><p>The reason that the double-busy-loop method requires checking for Mode 3 but this method does not is that the double-busy-loop method is not cycle-counted, so you might be at the very end of HBlank which is problematic. Since this method is cycle-counted, you know that if HBlank has begun, you are at or near the start of it.</p><p>If we make a similar list of pros and cons for this method, this is what it might look like:</p><h2 id="hybrid-cycle-counting" tabindex="-1"><a class="header-anchor" href="#hybrid-cycle-counting" aria-hidden="true">#</a> Hybrid cycle-counting</h2><p><strong>Pros</strong></p><ul><li>may exit very early if HBlank is longer</li><li>allows enough time during blanking to write to up to three registers</li><li>never takes longer than one scanline</li></ul><p><strong>Cons</strong></p><ul><li>requires all code to be constant-time</li><li>requires tedious cycle-counting</li></ul><p>This method can work well in many circumstances, and is especially suited to frequent effects that modify multiple registers and need to exit quickly to avoid taking too much CPU time. This method can even work reasonably well when used on every scanline through the Mode 2 interrupt.</p><p>All three of these methods can generate great-looking effects, but I think the third one is an especially attractive option.</p><p>Congrats! You made it to the end of the tutorial! I bet you&#39;re tired of reading it, and I&#39;m tired of writing it too. So thanks for reading, see you next time!</p><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/gbdev/gbdev.github.io/edit/dev/website/guides/lyc_timing.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><!----><!----></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.4be7e843.js" defer></script>
  </body>
</html>
